# 1. JVM中比较常见的三种垃圾收集算法

- 标记-清除算法 Mark-Sweep
- 标记-复制算法简称复制算法 Mark-Copying
- 标记-压缩算法或标记-整理 Mark-Compact

|          | 标记-清除算法<br/>(Mark-Sweep)                               | 标记-复制算法<br/>(Mark-Copying)                             | 标记-压缩算法<br/>(Mark-Compact)                             |
| :------: | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|   背景   | 非常基础和常见的垃圾收集算法                                 | 为了解决标记-清除算法在垃圾收集效率方面的缺陷                | **标记-清除算法**可以应用在老年代，但是该算法不仅执行效率低下，而且还会产生内存碎片<br/>**复制算法**的高效性是建立在存活对象少、垃圾对象多的前提下的，这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象，如果依然使用复制算法，复制的成本也将很高 |
| 执行过程 | <font color="red">标记：</font>从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象<br/><font color="red">清除：</font>对堆内存从头到尾进行线性的遍历，若某个对象在其Header中没有标记为可达对象，则将其回收（**这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里**） | <font color="red">将活着的内存空间分为两块，每次只使用其中一块</font>，在GC时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，**交换两个内存的角色**，最后完成垃圾回收 | <font color="red">第一阶段：</font>和标记清除算法一样，从根节点开始标记所有被引用对象<br/><font color="red">第二阶段：</font>将所有存活对象压缩到内存的一端，按顺序排放，之后，清理边界外所有的空间<br/>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<font color="red">标记-清除-压缩(Mark-Sweep-Compact)算法</font> |
|   优点   |                                                              | 1. 实现简单，运行高效<br/>2. 复制以后保证空间的连续性，不会出现“碎片”问题 | 1. 消除了标记-清除算法当中，内存区域分散的缺点<br/>2. 消除了复制算法当中，内存减半的高额代价 |
|   缺点   | 1. 效率不算高<br/>2. GC时，需要STW，导致用户体验差<br/>3. 清理出来的空闲内存不连续，会产生内存碎，**需维护一个空闲列表** | 1. **需要两倍的内存空间**<br/>2. 如果系统中的存活对象很多，复制算法不会很理想<br/>3. 对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或时间开销也不小 | 1. 从效率上来说，要低于复制算法<br/>2. 移动对象的同时，还需要调整引用的地址<br>3. 移动过程中，需要全程暂停用户应用程序，即：STW |
| 应用场景 | 老年代                                                       | 在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间，回收性价比很高<br/>现在的商业虚拟机都是用这种收集算法**回收新生代** | 老年代                                                       |
|   速度   | 中等                                                         | 最快                                                         | 最慢                                                         |
| 空间开销 | 少(但会堆积碎片)                                             | 通常需要存活对象的两倍大小(不堆积碎片)                       | 少(不堆积碎片)                                               |
| 移动对象 | 否                                                           | 是                                                           | 是                                                           |

# 2. 指针碰撞(Bump the Pointer)

- 如果内存空间以规整和有序的方式分布，即**已用和未用的内存都各自一边**，**彼此之间维系着一个记录下一次分配起始点的标记指针**，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做**指针碰撞(Bump the Pointer)** 

# 3. 空闲列表(Free List)

- 如果内存不是规整的，**已使用的内存和未使用的内存相互交错**，那么虚拟机将采用的是空闲列表法来为对象分配内存，意思是虚拟机**维护了一个列表，记录上哪些内存块是可用的**，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为**空闲列表( Free List )**

# 4. 分代收集算法

- **没有最好的算法，只有最合适的算法**
- **分代收集算法**，是基于这样一个事实：<font color="red">不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</font>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率
  
  - 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收
- 目前几乎所有的GC都是采用分代收集( Generational Collecting) 算法执行垃圾回收

- **在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点**

  - |           分代            | 特点                                                         |
    | :-----------------------: | :----------------------------------------------------------- |
    |  年轻代<br/>(Young Gen)   | **年轻代特点**：区域相对老年代较小，**对象生命周期短**、存活率低，回收频繁<br/>这种情况复制算法的回收整理，速度是最快的。**复制算法的效率只和当前存活对象大小有关**，因此很适用于年轻代的回收。而**复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解** |
    | 老年代 <br/>(Tenured Gen) | **老年代特点**：区域较大，**对象生命周期长**、存活率高，回收不及年轻代频繁<br/>这种情况存在大量存活率高的对象，复制算法明显变得不合适,**一般是由标记-清除或者是标记-清除与标记-整理的混合实现**<br/>Mark阶段的开销与存活对象的数量成正比<br/>sweep阶段的开销与所管理区域的大小成正相关<br/>Compact阶段的开销与存活对象的数据成正比 |

  - 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用Serial old执行Full GC以达到对老年代内存的整理

- 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代

# 5. 增量收集

- 上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。**在stop the World状态下**，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，**将严重影响用户体验或者系统的稳定性**。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了**增量收集(Incremental Collecting) 算法**的诞生。

- **基本思想**
  - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以<font color="red">**让垃圾收集线程和应用程序线程交替执行**</font>。**每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成**
  - 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，**允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**
- 缺点
  - 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，**因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降**

# 6. 分区算法

- 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。**为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿**

- **分代算法**将按照**对象的生命周期长短**划分成两个部分，**分区算法**将**整个堆空间**划分成连续的不同小区间

- **每一个小区间都独立使用，独立回收**。这种算法的好处是可以控制一次回收多少个小区间

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210318205416241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


# Reference

- [尚硅谷JVM详解](https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&seid=4147230974336755611)
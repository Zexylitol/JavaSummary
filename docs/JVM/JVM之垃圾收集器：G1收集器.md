
# 简介

- 官方给G1设定的目标是：<font color="red">**在延迟可控的情况下获得尽可能高的吞吐量**</font>，开创了收集器面向**局部收集**的设计思路和**基于Region的**内存布局形式
  - **G1 (Garbage- First)是一款面向服务端应用的垃圾收集器**，主要针对**配备多核CPU及大容量内存的机器**，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征
- 在JDK1.7版本正式启用，移除了Experimental的标识，**是JDK 9以后的默认垃圾回收器**，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”
  - CMS已经在JDK 9中被标记为废弃(deprecated)。在jdk8中还不是默认的垃圾回收器，需要使用-XX: +UseG1GC来启用
- <font color="red">复制算法+标记-压缩算法、并发+并行回收和"Stop-the-world"机制</font>

# 为什么叫做Garbage First(G1)?

- **G1是一个并行回收器**，它把堆内存分割为很多不相关的区域(Region) (物理上不连续的)。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等

- **G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾收集的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，<font color="blue">**在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region**</font>

- 由于这种方式的**侧重点在于回收垃圾最大量的区间(Region)** ，所以给G1一个名字:垃圾优先(Garbage First) 

# G1回收器的特点

## 优势

- 1. **并行与并发**

  - 并行性：G1在回收期间，**可以有多个GC线程同时工作**，有效利用多核计算能力。**此时用户线程STW**(只要是并行回收就一定会STW)
  - 并发性：**G1拥有与应用程序交替执行的能力**，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

- 2. **分代收集**

  - 从分代上看，**G1依然属于分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区，但从堆的结构上看，**它不要求整个Eden区、年轻代或者老年代都是连续的**，也不再坚持固定大小和固定数量
  - **将堆空间分为若干个区域(Region) , 这些区域中包含了逻辑上的年轻代和老年代**
  - 和之前的各类回收器不同，**它同时兼顾年轻代和老年代**，对比其他回收器，或者工作在年轻代，或者工作在老年代

- 3. **空间整合**

  - CMS：标记- 清除算法、内存碎片、 若干次GC后进行一次碎片整理

- **G1将内存划分为一个个的region，内存的回收是以region作为基本单位的**，<font color="red">G1从整体来看是基于"标记-压缩"算法实现的收集器，但从局部（两个Region之间）上看又是基于"标记-复制"算法实现</font>，两种算法**都可以避免内存碎片**。这种特性有利于程序长时间运行，**分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC**。尤其是当Java堆非常大的时候，G1的优势更加明显

- 3. **可预测的停顿时间模型(Pause Prediction Model)**(即:软实时soft real-time)

  - 这是G1相对于CMS的另一大优势，**G1除了追求低停顿外，还能建立可预测的停顿时间模型**，能让使用者明确**指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不得超过N毫秒**

    - 由于分区的原因，**G1可以只选取部分区域进行内存回收**，**这样缩小了回收的范围**，有计划的避免在整个Java堆中进行全区域的垃圾收集，因此对于**全局停顿情况**的发生也能得到较好的控制

- G1跟踪各个Region里面的垃圾收集的价值大小(价值即回收所获得的空间大小以及回收所需时间的经验值)，**在后台维护一个优先列表，每次根据用户设定允许的收集时间，优先回收价值最大的Region**。

  - 这种使用Region划分内存空间以及**具有优先级的区域回收方式**，保证了G1收集器在**有限的时间内**可以获取**尽可能高的收集效率**
  - 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多

## 缺点

- 相较于CMS，G1还不具备全方位、压倒性优势，比如在用户程序运行过程中，G1无论是为了垃圾收集产生的**内存占用(Footprint) 还是程序运行时的额外执行负载**(Overload) 都要比CMS要高

- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间



# G1收集器的运作过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411203140147.png#pic_center)


|                       过程                       | 说明                                                         |
| :----------------------------------------------: | :----------------------------------------------------------- |
|          初始标记<br/>(Initial Marking)          | <font color="red">仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值</font>，让下一阶段用户线程并发运行时，能正确地在可用的Region分配新对象。**这个阶段需要停顿线程，但耗时很短**，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段并没有额外的停顿。 |
|        并发标记<br/>(Concurrent Marking)         | <font color="red">从GC Root开始对堆中的对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</font>，**这阶段耗时较长，但可与用户并发执行**。当对象图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象 |
|           最终标记<br/>(Final Marking)           | 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录 |
| 筛选回收<br/>(Live Data Counting and Evacuation) | 负责更新Region的统计数据，<font color="red">对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</font>，可以自由选择任意多个Region构成回收集，**然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间**。这里的操作涉及存活对象的移动，是**必须暂停用户线程，由多条收集器线程并行完成的** |

- TAMS:G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于**并发回收**过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上

- SATB:原始快照算法

# G1参数设置

- -XX:+UseG1GC：手动指定使用G1收集器执行内存回收任务

- -XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000

- -XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms

- -XX:ParallelGCThread：设置STW时GC线程数的值。最多设置为8

- -XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/ 4左右

- -XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45

# G1回收器的常见操作步骤

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

- 第一步:开启G1垃圾收集器
- 第二步:设置堆的最大内存
- 第三步:设置最大的停顿时间

G1中提供了三种垃圾回收模式: YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发

# G1回收器的适用场景

- **面向服务端应用，针对具有大内存、多处理器的机器**。(在普通大小的堆里表现并不惊喜)

- 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案
  - 如:在堆大小约6GB或更大时，可预测的暂停时间可以低于8.5秒; (**G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长**)

- 用来替换掉JDK1.5中的CMS收集器
  - 在下面的情况时，使用G1可能比CMS好:
    - ①超过50%的Java堆被活动数据占用
    - ②对象分配频率或年代提升频率变化很大
    - ③GC停顿时间过长(长于0.5至1秒)。

- HotSpot垃圾收集器里，**除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作**，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，**系统会调用应用程序线程帮助加速垃圾回收过程**

# Region的使用介绍

- 使用G1收集器时，**它将整个Java堆划分成约2048个大小相同的独立Region块**，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB, 32MB。可以通过-XX: G1HeapRegionSize设定。**所有的Region大小相同，且在JVM生命周期内不会被改变**

- 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,它们都是一部分Region (不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411203240890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


- 一个region 有可能属于Eden， Survivor 或者Old/Tenured内存区域。但是**一个region只可能属于一个角色**。图中的E表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。
- G1垃圾收集器还增加了一种新的内存区域，**叫做Humongous内存区域**，如图中的H块。**主要用于存储大对象**，如果超过1. 5个region，就放到H，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

## 设置H的原因

- **对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响**。为了解决这个问题，**G1划分了一个Humongous区，它用来专门存放大对象**。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待



# Reference

- [尚硅谷JVM详解](https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&seid=11705427724146495636)
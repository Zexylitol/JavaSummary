# 1. 并不是所以的对象都分配到堆上，还可以分配到哪里？

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过**逃逸分析(Escape Analysis)**后发现，**一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

JIT编译器在编译期间根据逃逸分析的结果，发现如果**一个对象并没有逃逸出方法的话，就可能被优化成栈上分配**。分配完成后，继续在调用栈内执行，最后**线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收**了

> 随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么"绝对"了。

在JDK6u23版本之后，HotSpot中默认就已经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过：

- 选项`-XX:+DoEscapeAnalysis`显式开启逃逸分析
- 通过选项`-XX: +PrintEscapeAnalysis`查看逃逸分析的筛选结果



# 2. 可以作为GC Roots的对象

1. 当前虚拟机栈中局部变量表中的引用的对象
2. 当前本地方法栈中局部变量表中的引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中的常量引用的对象

# 3. 为什么新生代分成3份且比例是8:1:1

新生代分分区或分三区的原因如下：

- 分三代能使老年代作为担保来应付s区容不下存活对象的情况，降低老年代的内存分配压力，通过设置两个s区来对年轻对象进行拦截，降低fullGc的次数

为什么默认比例是8:1:1

- 《深入理解虚拟机》一书里有描述，IBM的一项研究表明新生代中有98%的对象是朝生夕灭的，换言之，每次mionrGC后存活的对象应该小于等于2%，所以看起来采用复制算法的新生代似乎可以不用将内存分成大小相等的两块了，但考虑到实验偏差以及实际情况的多样性，jvm默认预留了10%的内存用于存放存活对象，新生代最优应该分成三块，所以得再预留一块10%的内存给s区，那么自然剩下的80%就是e区的大小了
















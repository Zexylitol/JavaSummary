# 内存溢出(OOM)

javadoc中对OutofMemoryError的解释是：

- **没有空闲内存，而且垃圾收集器也无法提供更多内存**

可能的原因：

-  Java虚拟机的堆内存设置不够（可以通过参数`-Xms、-Xmx`调整）
- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)

# 内存泄露(Memory Leak)

内存泄露(Memory Leak)：

- **对象不会再被程序用到了，但是GC又不能回收他们，长时间下去也会OOM**

可能的原因：

- 单例模式：单例的生命周期和应用程序一样长，单例程序中如果持有对外部对象的引用，那么这个外部对象是不能被回收的，则会导致内存泄露的产生
- 一些提供close的资源未关闭导致内存泄露：数据库连接、网络连接和io连接必须手动close，否则不能被回收

# 对比

- 内存溢出代码本身没有原则问题，最多算是代码品质不高，想要消除报错只能增加堆内存或优化代码
- 内存泄露是由于代码存在缺陷，如果不修改代码问题，即使分配再大的内存最终也会报错

# 如何解决OOM

1. 要解决OOM异常或heap space的异常，一般的手段是首先通过**内存映像分析工具**(如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(MemoryLeak)还是内存溢出(Memory Overflow)
2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(`-Xmx`与`-Xms`) ，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
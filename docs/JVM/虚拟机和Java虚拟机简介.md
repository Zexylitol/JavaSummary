<!-- GFM-TOC -->

* [1. 虚拟机](#_1-虚拟机)
* [2. Java虚拟机](#_2-Java虚拟机)
  * [2.1 简介](#_21-简介)
  * [2.2 作用](#_22-作用)
  * [2.3 特点](#_23-特点)
* [3. 基于栈的指令集架构和基于寄存器的指令集架构](#_3-基于栈的指令集架构和基于寄存器的指令集架构)
  * [3.1 基于栈式架构的特点](#_31-基于栈式架构的特点)
  * [3.2 基于寄存器架构的特点](#_32-基于寄存器架构的特点)
  * [3.3 举例](#_33-举例)
* [4. HotSpot VM](#_4-HotSpot-VM)
* [5 JVM的生命周期](#_5-JVM的生命周期)
* [Reference](#Reference)
<!-- GFM-TOC -->

## 1. 虚拟机

所谓虚拟机（Virtual Machine）就是一台虚拟的计算机，它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为**系统虚拟机**和**程序虚拟机**，在上面运行的软件都被限制于虚拟机提供的资源中。

- 系统虚拟机：Visual Box，VMware等就属于系统虚拟机，**完全是对物理计算机的仿真**，提供一个可运行完整操作系统的软件平台
- 程序虚拟机：典型代表就是Java虚拟机，**专门为执行单个计算机程序而设计**，在Java虚拟机中执行的指令称为Java字节码指令

## 2. Java虚拟机

### 2.1 简介

- Java虚拟机（Java Virtual Machine，JVM）是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成（**只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行**）
- JVM平台的各种语言可以共享Java虚拟机带来的**跨平台性、优秀的垃圾回收机制以及可靠的即时编译器**
- 所有的Java程序都运行在Java虚拟机内部，**JVM是Java技术的核心**

### 2.2 作用

- **Java虚拟机就是二进制字节码的运行环境**，负责装载字节码到其内部，**解释/编译为对应平台上的机器指令执行**

### 2.3 特点

- 一次编译、到处运行
- 自动内存管理
- 自动垃圾回收功能

## 3. 基于栈的指令集架构和基于寄存器的指令集架构

### 3.1 基于栈式架构的特点

- Java编译器输入的指令流基本上是一种基于栈的指令集架构
- 设计和实现更简单，**适用于资源受限的系统**
- 避开了寄存器的分配难题：使用**零地址指令方式**（**零地址指令又叫堆栈运算指令， 必须依赖于栈， 操作数都来自栈， 栈顶和次栈顶**）分配
- 指令流中的指令大部分是零地址指令，其**执行过程依赖于操作栈。指令集更小，编译器容易实现**
- 不需要硬件支持，**可移植性更好，更好实现跨平台**

### 3.2 基于寄存器架构的特点

- 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虛拟机
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一-项操作
- 在大部分情况下，基于寄存器架构的指令集往往都**以一地址指令、二地址指令和三地址指令为主**（操作码+操作数），而基于栈式架构的指令集却是以零地址指令为主

### 3.3 举例

#### 3.3.1 基于栈的计算流程（以Java虚拟机为例）

```Java
public class InstructionTes {
    public static void main(String[] args) {
        int a = 2;
        int b = 3;
        int c = a + b;
    }
}
```

对应的字节码指令：

```java
0 iconst_2   // 常量2入栈
1 istore_1 
2 iconst_3   // 常量3入栈
3 istore_2
4 iload_1    
5 iload_2
6 iadd       // 常量2 3 出栈相加，结果入栈
7 istore_3
8 return
```

**查看字节码：**

- 使用javap指令：`javap -v InstructionTes.class`

- 在IntelliJ IDEA中安装 ==Jclasslib== 插件

#### 3.3.2 基于寄存器的计算流程（以ARM指令集为例）

```
MOV R1, #2 ; 把常数2传给R1
MOV R2, #3 ; 把常数3传给R2
ADD R0,R1,R2 ;R0=R1+R2
```

### 3.4 总结

- 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的；优点是跨平台、指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令

## 4. HotSpot VM

### 4.1 简介

- JDK1.3时，HotSpot VM成为默认虚拟机
- 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot

- 名称中的HotSpot指的就是它的热点代码探测技术
  - 通过计数器找到最具有编译价值代码，触发**即时编译或栈上替换**
  - 通过编译器与解释器协同工作，在最优化的**程序响应时间**与最佳**执行性能中取得平衡**

### 4.2 整体结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303214623224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


- ClassLoader
  - Java源文件经过编译后生成二进制字节码，通过类加载器进入JVM运行
- JVM内存结构
  - 类 ： 方法区
  - 实例对象 ：堆
  - 堆里的实例对象调用方法时会用到虚拟机栈、程序计数器、本地方法栈
- 执行引擎
  - 方法执行时每行代码由解释器执行
  - 方法里的热点代码（频繁调用的代码）由JIT Compiler做优化后执行
  - GC对堆里不再被引用的对象进行垃圾回收
- 本地方法接口
  - Java代码不方便实现的功能必须调用底层操作系统的功能
  - 借助本地方法接口调用底层操作系统的一些方法

## 5. JVM的生命周期

### 5.1 虚拟机的启动

- Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类由虚拟机的具体实现指定

### 5.2 虚拟机的执行

- 程序开始执行时JVM才运行，程序结束时JVM就停止
- **执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程**

### 5.3 虚拟机的退出

有如下几种情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虛拟机进程终止
- 某线程调用Runtime类或System类的`exit`方法， 或Runtime类的`halt`方法，并且Java安全管理器也允许这次exit或halt操作
- 除此之外，JNI ( Java Native Interface) 规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虛拟机的退出情况

## Reference

- [尚硅谷详解JVM虚拟机](https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&seid=17650210674210078083)
# 0 概述

如何将堆上的对象分配到栈，需要使用逃逸分析手段。

这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸

- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中

```java
public void method() {
    // 没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。
    Object o = new Object();
    //...
    o = null;
}

public StringBuffer createStringBuffer() {
    // 发生逃逸的对象
    StringBuffer sb = new StringBuffer();
    //...
    return sb;
}
```

**如何快速判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用**

# 1 参数设置

在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过：

- 选项`-XX:+DoEscapeAnalysis`显式开启逃逸分析
- 通过选项`-XX: +PrintEscapeAnalysis`查看逃逸分析的筛选结果

# 2 代码优化

使用逃逸分析，编译器可以对代码做如下优化：

- <span style="color:red">栈上分配</span>。将堆分配转化为栈分配
- <span style="color:red">同步省略</span>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
- <span style="color:red">分离对象或标量替换</span>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在cPU寄存器中

## 2.1 栈上分配

- JIT编译器在编译期间根据逃逸分析的结果，发现如果**一个对象并没有逃逸出方法的话，就可能被优化成栈上分配**。分配完成后，继续在调用栈内执行，最后**线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收**了
- 常见的栈上分配的场景：给成员变量赋值、方法返回值、实例引用传递

## 2.2 同步省略

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。
- 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

```java
public void method() {
    Object o = new Object();
    synchronized(o) {
        //...
    }
}
```

代码中对`o`这个对象进行加锁，但是`o`对象的生命周期只在`method()`方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：

```java
public void method() {
    Object o = new Object();
	//...
}
```

**同步省略、栈上分配----只有在字节码文件加载到内存之后才会进行判断**

## 2.3 标量替换

- **标量（scalar）**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
- 相对的，那些还可以分解的数据叫做**聚合量(Aggregate)** ，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
- 在JIT阶段，如果经过**逃逸分析**，发现**一个对象不会被外界访问**的话，那么经过JIT优化，就会**把这个对象拆解成若干个其中包含的若干个成员变量来代替**。这个过程就是**标量替换**。

```java
public static void main(String[] args) {
    alloc();
}

private static void alloc() {
    Point point = new Point(1, 2);
    System.out.println(ponit.x + " " + point.y);
}
class Point {
    private int x;
    private int y;
}
```

以上代码经过标量替换后，就会变成：

```java
private static void alloc() {
    int x = 1;
    int y = 2;
    System.out.println(x + " " + y);
}
```

可以看到，`Point`这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以**大大减少堆内存的占用**。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

标量替换为栈上分配提供了很好的基础。

标量替换参数设置∶
参数`-XX:+EliminateAllocations`:开启了标量替换(默认打开)，允许将对象打散分配在栈上。

# 3 小结

- 关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也**并不是十分成熟的**
- 其根本原因就是**无法保证逃逸分析的性能消耗一定能高于它的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程**。
  - 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
- 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。
- 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。**Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上**。
- 目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论:对象实例都是分配在堆上。
















<!-- GFM-TOC -->

- [简介](#简介)
- [模板](#模板)
  - [模板一](#模板一)
  - [模板二](#模板二)
- [剑指Offer 53-I. 在排序数组中查找数字I](#剑指Offer-53-I-在排序数组中查找数字I)
- [LeetCode 1482. 制作m束花所需的最少天数I](#LeetCode-1482-制作m束花所需的最少天数)
- [LeetCode 1011. 在D天内送达包裹的能力](#LeetCode-1011-在D天内送达包裹的能力)

<!-- GFM-TOC -->

# 简介

- 二分查找(Binary Search)算法，也叫折半查找算法，二分查找针对的是一个**有序的数据集合**，查找思想有点类似分治思想，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0
- 二分查找的时间复杂度为：<img src="http://latex.codecogs.com/gif.latex?\  O \left ( logn \right )" />
- **二分容易出错的细节**：循环退出条件、区间上下界更新方法、返回值选择
- 二分查找的应用场景比较有限：底层必须依赖数组，并且要求数据有序；对于较小规模的数据查找，直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作
- **有序数组，<img src="http://latex.codecogs.com/gif.latex?\  O \left ( n \right )  " />复杂度的优化一般都是往二分查找这个思路上去考虑的**
- **二分特征：满足条件的最小或者满足条件的最大**

## 模板

<img src="https://i.im5i.com/2021/05/09/C60xL.png" alt="C60xL.png" border="0" />

### 模板一

- 找大于等于给定数的第一个位置 （满足某个条件的第一个数）

```java
// 判断条件很复杂时用check函数，否则if后直接写条件即可
boolean check(int mid) {
    // ...
    return ...;
}
// if的判断条件是让mid落在满足你想要结果的区间内
int binarySearch(int left, int right) {
    while (left < right) {
        int mid = left + (right - left) / 2; // 左中位数
        if (check(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

> 关于取中位数，一个记忆的口诀是「左动取左，右动取右」，即 if (...) left = mid + 1; 归为「左动」，对应左中位数；if (...) right = mid - 1; 归为「右动」，对应右中位数。

### 模板二

- 找小于等于给定数的最后一个数 （满足某个条件的最后一个数）

```java
// 判断条件很复杂时用check函数，否则if后直接写条件即可
boolean check(int mid) {
    // ...
    return true;
}

int binarySearch(int left, int right) {
    while (left < right) {
        int mid = left + (right - left + 1) / 2; // 右中位数
        if (check(mid)) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

- ☆推荐阅读☆：[写对二分查找不能靠模板](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)

# 剑指Offer 53-I. 在排序数组中查找数字I

- 时间复杂度：<img src="http://latex.codecogs.com/gif.latex?\  O \left ( n \right )  " />
- 空间复杂度：<img src="http://latex.codecogs.com/gif.latex?\  {O} \left ( 1 \right )  " />

```java
class Solution {
   public int search(int[] nums, int target) {
       int n = nums.length;
       if (n == 0) {
           return 0;
       }
        int left = left_bound(nums, target);
        int right = right_bound(nums, target);
        if (left == -1 || right == -1) {
            return 0;
        } else {
            return right - left + 1;
        }
    }

    // 寻找第一个小于等于target的索引
    public int right_bound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            // 右动取右
            int mid = left + (right - left + 1) / 2; 
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return nums[left] == target ? left : -1;
    }
	// 寻找第一个大于等于target的索引
    public int left_bound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            // 左动取左
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left] == target ? left : -1;
    }
}
```

# LeetCode 1482. 制作m束花所需的最少天数

- 二分特征：满足条件的最小或者满足条件的最大
- 每束花需要 k 朵花，需要制作 m 束花，因此一共需要 k x m 朵花。如果花园中的花朵数量少于 k x m ，即数组 bloomDay 的长度小于 k x m，则无法制作出指定数量的花束，返回 -1。如果数组 bloomDay 的长度大于或等于 k x m，则一定可以制作出指定数量的花束

- 枚举天数，给定序列可以制作出的花束数量是关于天数递增的

```java
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if (m > bloomDay.length / k) {
            return -1;
        }
        int low = Integer.MAX_VALUE;
        int high = 0;
        int n = bloomDay.length;
        for (int i = 0; i < n; i++) {
            low = Math.min(low, bloomDay[i]);
            high = Math.max(high, bloomDay[i]);
        }
        while (low < high) {
            int days = (high - low) / 2 + low;
            if (canMake(bloomDay, days, m, k)) {
                high = days;
            } else {
                low = days + 1;
            }
        }
        return low;
    }

    public boolean canMake(int[] bloomDay, int days, int m, int k) {
        int res = 0;
        int flowers = 0;
        int n = bloomDay.length;
        for (int i = 0; i < n && res < m; i++) {
            if (bloomDay[i] <= days) {
                flowers++;
                if (flowers == k) {
                    res++;
                    flowers = 0;
                }
            } else {
                flowers = 0;
            }
        }
        return res >= m;
    }
}
```

- 时间复杂度：<img src="http://latex.codecogs.com/gif.latex?\ \textit{O}(n \log (\textit{high} - \textit{low}))" />，其中 n 是数组 bloomDay 的长度，high 和 low 分别是数组 bloomDay 中的最大值和最小值。

- 空间复杂度：<img src="http://latex.codecogs.com/gif.latex?\  {O} \left ( 1 \right )  " />

  

# LeetCode 1011. 在D天内送达包裹的能力

```java
class Solution {
    public int shipWithinDays(int[] weights, int D) {
        // 确定二分查找左右边界
        int left = getMax(weights);
        int right = getSum(weights);
        
        //int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();
        
        if (D == 1) {
            return right;
        }

        // 左边界
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (check(weights, D, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left; 
    }

    // 运载能力为cap的情况下，能否在D天内运载完毕
    public boolean check(int[] weights, int D, int cap) {
        int time = 0;
        int weight = 0;
        for (int i = 0; i < weights.length; i++) {
            weight += weights[i];
            if (weight > cap) {
                weight = weights[i];
                time++;
            }
        }
        time++;         // 剩余的包裹还需要一天
        return time <= D;
    }

    // 获取包裹的最大重量
    public int getMax(int[] weights) {
        int res = 0;
        for (int w : weights) {
            res = Math.max(res, w);
        }
        return res;
    }

    // 获取包裹的总重量
    public int getSum(int[] weights) {
        int res = 0;
        for (int w : weights) {
            res += w;
        }
        return res;
    }
}
```



# Reference

- [最简二分模板——秒杀95%的二分题](https://www.acwing.com/blog/content/346/)
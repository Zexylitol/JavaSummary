<!-- GFM-TOC -->

- [模板](#模板)

- [LeetCode 131 分割回文串](#LeetCode-131-分割回文串)
- [LeetCode 78 子集](#LeetCode-78-子集)
- [LeetCode 39. 组合总和](#LeetCode-39-组合总和)
- [LeetCode 93. 复原IP地址](#LeetCode-93-复原IP地址)

<!-- GFM-TOC -->

# 模板

```python
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop()

```

```java
public void backtrace(未搜索区域,res,path) {
    if (为搜索区域满足结束条件) {
        res.add(new ArrayList<String>(path));
        return ;
    }
    for (选择 : 未搜索区域当前可能的选择) {
        if (当前选择符合要求) {
            path.add(当前选择);
            backtrace(新的未探索区域,res,path);
            path.remove(path.size()-1);            
        }
    }
}
```

# LeetCode 131 分割回文串

- 时间复杂度：$O(N * 2 ^ N)$，因为总共有 $O(2^N)$ 种分割方法，每次分割都要判断是否回文需要 $O(N)$ 的时间复杂度
- 空间复杂度：$O(2^N)$，返回结果最多有$O(2^N)$种划分方法

# LeetCode 78 子集

- ```c++
  // 找到一个长度为 nn 的序列 aa 的所有子序列，代码框架是这样的:
  vector<int> t;
  void dfs(int cur, int n) {
      if (cur == n) {
          // 记录答案
          // ...
          return;
      }
      // 考虑选择当前位置
      t.push_back(cur);
      dfs(cur + 1, n, k);
      t.pop_back();
      // 考虑不选择当前位置
      dfs(cur + 1, n, k);
  }
  ```

- 时间复杂度：$O(n \times 2 ^ n)$。一共 $2^n$ 个状态，每种状态需要 $O(n)$ 的时间来构造子集

- 空间复杂度：$O(n)$。临时数组 $t$ 的空间代价是 $O(n)$，递归时栈空间的代价为 $O(n)$

# LeetCode 39. 组合总和

- https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/

<center><img src="https://i.loli.net/2021/04/25/WPkMgel4RrBwbf3.png"/></center>

```java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        dfs(candidates, target, new ArrayList<>(), 0);
        return res;
    }

    public void dfs(int[] candidates, int target, List<Integer> path, int begin) {
        if (target == 0) {
            res.add(new ArrayList<Integer>(path));
        }

        for (int i = begin; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                path.add(candidates[i]);
                // 每一次搜索的时候设置下一轮搜索的起点 begin
                // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错
                dfs(candidates, target - candidates[i], path, i);
                path.remove(path.size() - 1);
            }
        }
    }
}
```

- 若不使用 `begin`变量，下面代码的输出为：`[[2,2,3],[2,3,2],[3,2,2],[7]]`

```java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        dfs(candidates, target, new ArrayList<>());
        return res;
    }

    public void dfs(int[] candidates, int target, List<Integer> list) {
        if (target == 0) {
            res.add(new ArrayList<Integer>(list));
        }

        for (int i = 0; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                list.add(candidates[i]);
                dfs(candidates, target - candidates[i], list);
                list.remove(list.size() - 1);
            }
        }
    }
}
```

# LeetCode 93. 复原IP地址



# 剑指Offer 38. 字符串的排列

- 不剪枝
  - 标准回溯，最后结果用`Set`去重

```java
class Solution {
    public String[] permutation(String s) {
        Set<String> list = new HashSet<>();
        char[] arr = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        boolean[] visited = new boolean[arr.length];
        dfs(arr, "", visited, list);
        return list.toArray(new String[0]);
    }
    public void dfs(char[] arr, String s,  boolean[] visited, Set<String> list)
    {
        if(s.length() == arr.length)
        {
            list.add(s);
            return;
        }
        for(int i=0; i<arr.length; i++)
        {
            if(visited[i]) continue;
            visited[i] = true;
            dfs(arr, s+String.valueOf(arr[i]), visited, list);
            visited[i] = false;
        }

    }
}
```



- 剪枝
  - 时间复杂度 $O(N!N)$ ： N为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 $N \times (N-1) \times (N-2) … \times 2 \times 1$ ，即复杂度为 $O(N!)$；字符串拼接操作 join() 使用 $O(N)$；因此总体时间复杂度为 $O(N!N)$
  - 空间复杂度 $O(N^2)$： 全排列的递归深度为 N ，系统累计使用栈空间大小为 $O(N)$；递归中辅助 Set 累计存储的字符数量最多为 $N + (N-1) + ... + 2 + 1 = (N+1)N/2$ ，即占用 $O(N^2)$的额外空间

```java
class Solution {
    List<String> res = new LinkedList<>();
    char[] c;
    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }

  	// x : 固定第x位字符
    public void dfs(int x) {
        if (x == c.length - 1) {
            res.add(String.valueOf(c));
            return ;
        }
        Set<Character> set = new HashSet<>();
        for (int i = x; i < c.length; i++) {
            if (set.contains(c[i])) continue;    // 剪枝 去重
            set.add(c[i]);
            swap(i, x);
            dfs(x + 1);
            swap(i, x);
        }
    }

    public void swap(int i, int x) {
        char tmp = c[i];
        c[i] = c[x];
        c[x] = tmp;
    }
}
```


<!-- GFM-TOC -->

- [模板](#模板)

- [LeetCode 131 分割回文串](#LeetCode-131-分割回文串)
- [LeetCode 78 子集](#LeetCode-78-子集)
- [LeetCode 39. 组合总和](#LeetCode-39-组合总和)
- [LeetCode 93. 复原IP地址](#LeetCode-93-复原IP地址)

<!-- GFM-TOC -->

# 模板

```python
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop()

```

```java
public void backtrace(未搜索区域,res,path) {
    if (为搜索区域满足结束条件) {
        res.add(new ArrayList<String>(path));
        return ;
    }
    for (选择 : 未搜索区域当前可能的选择) {
        if (当前选择符合要求) {
            path.add(当前选择);
            backtrace(新的未探索区域,res,path);
            path.remove(path.size()-1);            
        }
    }
}
```

# LeetCode 131 分割回文串

- 时间复杂度：$O(N * 2 ^ N)$，因为总共有 $O(2^N)$ 种分割方法，每次分割都要判断是否回文需要 $O(N)$ 的时间复杂度
- 空间复杂度：$O(2^N)$，返回结果最多有$O(2^N)$种划分方法

# LeetCode 78 子集

- ```c++
  // 找到一个长度为 nn 的序列 aa 的所有子序列，代码框架是这样的:
  vector<int> t;
  void dfs(int cur, int n) {
      if (cur == n) {
          // 记录答案
          // ...
          return;
      }
      // 考虑选择当前位置
      t.push_back(cur);
      dfs(cur + 1, n, k);
      t.pop_back();
      // 考虑不选择当前位置
      dfs(cur + 1, n, k);
  }
  ```

- 时间复杂度：$O(n \times 2 ^ n)$。一共 $2^n$ 个状态，每种状态需要 $O(n)$ 的时间来构造子集

- 空间复杂度：$O(n)$。临时数组 $t$ 的空间代价是 $O(n)$，递归时栈空间的代价为 $O(n)$

# LeetCode 39. 组合总和

- https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/

<center><img src="https://i.loli.net/2021/04/25/WPkMgel4RrBwbf3.png"/></center>

```java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        dfs(candidates, target, new ArrayList<>(), 0);
        return res;
    }

    public void dfs(int[] candidates, int target, List<Integer> path, int begin) {
        if (target == 0) {
            res.add(new ArrayList<Integer>(path));
        }

        for (int i = begin; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                path.add(candidates[i]);
                // 每一次搜索的时候设置下一轮搜索的起点 begin
                // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错
                dfs(candidates, target - candidates[i], path, i);
                path.remove(path.size() - 1);
            }
        }
    }
}
```

- 若不使用 `begin`变量，下面代码的输出为：`[[2,2,3],[2,3,2],[3,2,2],[7]]`

```java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        dfs(candidates, target, new ArrayList<>());
        return res;
    }

    public void dfs(int[] candidates, int target, List<Integer> list) {
        if (target == 0) {
            res.add(new ArrayList<Integer>(list));
        }

        for (int i = 0; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                list.add(candidates[i]);
                dfs(candidates, target - candidates[i], list);
                list.remove(list.size() - 1);
            }
        }
    }
}
```

# LeetCode 93. 复原IP地址
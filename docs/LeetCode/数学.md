<!-- GFM-TOC -->

- [LeetCode 7. 整数反转](#LeetCode-7-整数反转)
- [LeetCode 12. 整数转罗马数字](#LeetCode-12-整数转罗马数字)
- [LeetCode 13. 罗马数字转整数](#LeetCode-13-罗马数字转整数)
- 位运算
  - [LeetCode 1720. 解码异或后的数组](#LeetCode-1720-解码异或后的数组)
  - [LeetCode 1734. 解码异或后的排列](#LeetCode-1734-解码异或后的排列)
  - [LeetCode 1310. 子数组异或查询](#LeetCode-1310-子数组异或查询)

<!-- GFM-TOC -->

# LeetCode 7. 整数反转

- $2^{31}-1 = 2147483647$
- $-2^{31} = 2147483648$
- 时间复杂度：$O(\log |x|)$。翻转的次数即 x 十进制的位数。
- 空间复杂度：$O(1)$。

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            if (res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE/10 && x%10 > 7)) {
                return 0;
            }
            if (res < Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE/10 && x%10 < -8)) {
                return 0;
            }
            res = res * 10 + x % 10;
            x = x / 10;
        }
        return res;
    }
}
```



# LeetCode 12. 整数转罗马数字

- 方法一：模拟+贪心
  - 确定罗马数字的规则：对于罗马数字从左到右的每一位，选择尽可能大的符号值
  - 时间复杂度：$O(1)$
  - 空间复杂度：$O(1)$

<center><img src="https://i.im5i.com/2021/05/14/CyKtz.png" alt="CyKtz.png" border="0" /></center>

```java
class Solution {
    int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        for (int i = 0; i < values.length; ++i) {
            int value = values[i];
            String symbol = symbols[i];
            while (num >= value) {
                num -= value;
                roman.append(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return roman.toString();
    }
}
```

- 方法二：硬编码数字
  - 时间复杂度：$O(1)$
  - 空间复杂度：$O(1)$

<center><img src="https://i.im5i.com/2021/05/14/CyPx5.png" alt="CyPx5.png" border="0" /></center>

```java
class Solution {
    String[] thousands = {"", "M", "MM", "MMM"};
    String[] hundreds  = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    String[] tens      = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    String[] ones      = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        roman.append(thousands[num / 1000]);
        roman.append(hundreds[num % 1000 / 100]);
        roman.append(tens[num % 100 / 10]);
        roman.append(ones[num % 10]);
        return roman.toString();
    }
}
```

# LeetCode 13. 罗马数字转整数

- 方法一：模拟

  - 时间复杂度：$O(n)$。其中 $n$ 是字符串 s 的长度。
  - 空间复杂度：$O(1)$。

  ```java
  class Solution {
      public int romanToInt(String s) {
          Map<String, Integer> map = new HashMap<>();
          init(map);
          int i = 0;
          char[] chars = s.toCharArray();
          int n = s.length();
          int res = 0;
          while (i < n - 1) {
              if (map.get(chars[i] + "") < map.get(chars[i + 1] + "")) {
                  res += map.get(chars[i] + "" + chars[i + 1]);
                  i += 2;
              } else {
                  res += map.get(chars[i] + "");
                  i++;
              }
          }
          if (i == n - 1) {
              res += map.get(chars[i] + "");
          }
          return res;
      }
  
      public void init(Map<String, Integer> map) {
          map.put("I", 1);
          map.put("IV", 4);
          map.put("V", 5);
          map.put("IX", 9);
          map.put("X", 10);
          map.put("XL", 40);
          map.put("L", 50);
          map.put("XC", 90);
          map.put("C", 100);
          map.put("CD", 400);
          map.put("D", 500);
          map.put("CM", 900);
          map.put("M", 1000);
      }
  }
  ```

- 方法二：模拟
  - 若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反
  - 时间复杂度：$O(n)$。其中 $n$ 是字符串 s 的长度。
  - 空间复杂度：$O(1)$。

```java
class Solution {
    Map<Character, Integer> symbolValues = new HashMap<Character, Integer>() {{
        put('I', 1);
        put('V', 5);
        put('X', 10);
        put('L', 50);
        put('C', 100);
        put('D', 500);
        put('M', 1000);
    }};

    public int romanToInt(String s) {
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            int value = symbolValues.get(s.charAt(i));
            if (i < n - 1 && value < symbolValues.get(s.charAt(i + 1))) {
                // 符号取反
                ans -= value;
            } else {
                ans += value;
            }
        }
        return ans;
    }
}
```



# LeetCode 1720. 解码异或后的数组

异或运算具有如下性质：

- 异或运算满足交换律和结合律；

- 任意整数和自身做异或运算的结果都等于 0，即 <img src="http://latex.codecogs.com/gif.latex?\ x \oplus x = 0" />

- 任意整数和 0 做异或运算的结果都等于其自身，即<img src="http://latex.codecogs.com/gif.latex?\ x \oplus 0 = 0 \oplus x = x" />。

<img src="https://i.im5i.com/2021/05/06/wkxVL.png" alt="wkxVL.png" border="0" />

```java
class Solution {
    public int[] decode(int[] encoded, int first) {
        int n = encoded.length;
        int[] arr = new int[n+1];
        arr[0] = first;
        for (int i = 1; i <= n; i++) {
            arr[i] = arr[i-1] ^ encoded[i-1];
        }
        return arr;
    }
}
```



# LeetCode 1734. 解码异或后的排列

```java
class Solution {
    public int[] decode(int[] encoded) {
        int n = encoded.length + 1;
        // 数组 perm 的全部元素的异或运算结果
        int total = 0;
        /**
         * 充分挖掘题目信息：数组perm是前n个正整数的排列，1~n
         */
        for (int i = 1; i <= n; i++) {
            total ^= i;
        }
        // odd 表示数组 encoded 的所有下标为奇数的元素的异或运算结果
        // odd 即为 perm 除了 perm[0] 以外的全部元素的异或运算结果
        int odd = 0;
        for (int i = 1; i < n - 1; i+=2) {
            odd ^= encoded[i];
        }
        int[] perm = new int[n];
        perm[0] = total ^ odd;
        // 计算过程同 LeetCode 1720. 解码异或后的数组的官方题解
        for (int i = 0; i < n - 1; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }
        return perm;
    }
}
```

- 时间复杂度：$O(n)$，其中 n 是原始数组 $\textit{perm}$ 的长度。计算 $\textit{total}$和 $\textit{odd}$ 各需要遍历长度为 $n-1$ 的数组 $\textit{encoded}$一次，计算原数组 $\textit{perm}$ 的每个元素值也需要遍历长度为 $n-1$ 的数组 $\textit{encoded}$ 一次。

- 空间复杂度：$O(1)$。注意空间复杂度不考虑返回值

# LeetCode 1310. 子数组异或查询

- 方法一：暴力

  - 如果数组 $\textit{arr}$ 的长度为 n，数组 $\textit{queries}$的长度为 $m$（即有 m 个查询），则最坏情况下每个查询都需要 $O(n)$ 的时间计算结果，总时间复杂度是 $O(nm)$，会超出时间限制

  ```java
  class Solution {
      public int[] xorQueries(int[] arr, int[][] queries) {
          int n = queries.length;
          int[] res = new int[n];
          for (int i = 0; i < n; i++) {
              int L = queries[i][0];
              int R = queries[i][1];
              for (int j = L; j <= R; j++) {
                  res[i] ^= arr[j];
              }
          }
          return res;
      }
  }
  ```

- 方法二：前缀异或

<center><img src="https://i.im5i.com/2021/05/12/CVR9W.png" alt="CVR9W.png" border="0" /></center>

```java
class Solution {
    public int[] xorQueries(int[] arr, int[][] queries) {
        int n = arr.length;
        int[] xors = new int[n + 1];
        for (int i = 0; i < n; i++) {
            xors[i + 1] = xors[i] ^ arr[i];
        }
        int m = queries.length;
        int[] res = new int[m];
        for (int i = 0; i < m; i++) {
            int L = queries[i][0];
            int R = queries[i][1];
            res[i] = xors[L] ^ xors[R + 1];
        }
        return res;
    }
}
```

- 时间复杂度：$O(n+m)$，其中 n 是数组 $\textit{arr}$ 的长度，m 是数组 $\textit{queries}$ 的长度。

- 空间复杂度：$O(n)$，其中 n 是数组 $\textit{arr}$的长度。






<!-- GFM-TOC -->

- [LeetCode 1190. 反转每对括号间的子串](#LeetCode-1190-反转每对括号间的子串)
- [LeetCode 1047 删除字符串中的所有相邻重复项](#LeetCode-1047-删除字符串中的所有相邻重复项)
- [剑指offer 09. 用两个栈实现队列](#剑指offer-09-用两个栈实现队列)
- 单调栈
  - [LeetCode 456. 132模式](#LeetCode-456-132模式)
  - [LeetCode 84. 柱状图中最大的矩形](#LeetCode-84-柱状图中最大的矩形)
  - [LeetCode 85. 最大矩形](#LeetCode-85-最大矩形)
  - [LeetCode 739. 每日温度](#LeetCode-739-每日温度)
  - [LeetCode 496. 下一个更大元素I](#LeetCode-496-下一个更大元素I)
- 最小栈
  - [LeetCode 155. 最小栈](#LeetCode-155-最小栈)
- 计算器
  - [LeetCode 224 基本计算器](#LeetCode-224-基本计算器)
  - [LeetCode 227. 基本计算器II](#LeetCode-227-基本计算器II)

<!-- GFM-TOC -->

# LeetCode 1190. 反转每对括号间的子串

- 方法一：栈
  - 遍历字符串，遇到左括号，则将此左括号所在的索引压入栈，遇到右括号，则弹出栈顶索引，反转[栈顶索引，当前右括号索引]之间的字符串
  - 再一次遍历字符串，删除其中的括号，返回
  - 时间复杂度：$O(n^2)$
  - 空间复杂度：$O(n)$

```java
class Solution {
    public String reverseParentheses(String s) {
        int n = s.length();
        if (n == 0) {
            return s;
        }
        Deque<Integer> stack = new LinkedList<>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < n; i++) {
            if (chars[i] == '(') {
                stack.addLast(i);
            } else if (chars[i] == ')') {
                reverse(chars, stack.removeLast(), i);
            } 
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (chars[i] != '(' && chars[i] != ')') {
                sb.append(chars[i]);
            }
        }
        return sb.toString();
    }

    public void reverse(char[] chars, int left, int right) {
        while (left < right) {
            char tmp = chars[left];
            chars[left] = chars[right];
            chars[right] = tmp;
            left++;
            right--;
        }
    }
}
```

# LeetCode 1047. 删除字符串中的所有相邻重复项

# 剑指offer 09. 用两个栈实现队列

# LeetCode 456. 132模式

# LeetCode 84. 柱状图中最大的矩形

# LeetCode 85. 最大矩形

- 当遍历到一个位置 $i$ 需要寻找数组中左边或者右边的所有数字和 $nums[i]$ 的大小关系的题目，可以考虑一下单调栈

# LeetCode 739. 每日温度

# LeetCode 496. 下一个更大元素I

# 剑指 Offer 30. 包含min函数的栈

- 方法：使用辅助栈
  - 数据栈：存储所有元素
  - 辅助栈：存储数据栈中所有**非严格降序**的元素
  - 时间复杂度：$O(1)$
  - 空间复杂度：$O(n)$

```java
class MinStack {

    Deque<Integer> stack;
    Deque<Integer> minStack;
    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
    }
    
    public void push(int x) {
        stack.addLast(x);
        if (minStack.isEmpty() || minStack.peekLast() >= x) {
            minStack.addLast(x);
        }
    }
    
    public void pop() {
        if (stack.removeLast().equals(minStack.peekLast())) {
            minStack.removeLast();
        }
    }
    
    public int top() {
        return stack.peekLast();
    }
    
    public int min() {
        return minStack.peekLast();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```



# LeetCode 155. 最小栈

- 最大栈：https://www.cnblogs.com/grandyang/p/7823424.html

# LeetCode 224. 基本计算器

# LeetCode 227. 基本计算器II

- 后缀表达式 / 逆波兰表达式：在逆波兰记法中，所有[操作符](https://zh.wikipedia.org/wiki/運算子)置于[操作数](https://zh.wikipedia.org/wiki/操作数)的后面，因此也被称为**后缀表示法**。逆波兰记法不需要括号来标识操作符的优先级

<center><img src="https://i.loli.net/2021/03/10/lZ2RuF39gtqMEwS.png" /></center>

<center><img src="https://i.loli.net/2021/03/10/5U2xhgfwkVWLeC9.png" /></center>

<center><img src="https://i.loli.net/2021/03/10/NEXaFvIZpuGnQm9.png"/></center>>

```java
/**
* 将得到的中缀表达式对应的List抓换成后缀表达式对应的List
* [1,+,(,(,2,+,3,),*,4,),-,5] -----> [1,2,3,+,4,*,+,5,–]
*
* 具体步骤如下：
* 1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 数字栈numbers，符号栈signs
* 2. 从左至右扫描中缀表达式；
* 3. 遇到操作数时，将其压s2；
* 4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
*    1） 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
*    2） 若优先级比栈顶运算符的高，也将运算符压入s1；
*    3） 若优先级小于等于栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；
* 5. 遇到括号时：
*    1) 如果是左括号“(”，则直接压入s1
*    2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
* 6. 重复步骤2至5，直到表达式的最右边
* 7. 将s1中剩余的运算符依次弹出并压入s2
* 8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
*
* @param ls
* @return
*/
```




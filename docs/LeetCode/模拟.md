<!-- GFM-TOC -->

- [Offer 29. 顺时针打印矩阵](#Offer-29-顺时针打印矩阵)
- [Offer 17. 打印从1到最大的n位数](#Offer-17-打印从1到最大的n位数)

<!-- GFM-TOC -->

# Offer 29. 顺时针打印矩阵

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return new int[0];
        }
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int[] order = new int[total];
        int row = 0, column = 0;
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 右 下 左 上
        int directionIndex = 0;
        for (int i = 0; i < total; i ++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0];
            int nextCol = column + directions[directionIndex][1];
            if (nextRow<0 || nextRow>=rows || nextCol<0 || nextCol>= columns || visited[nextRow][nextCol]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
}
```

# Offer 17. 打印从1到最大的n位数

### 方法一：不能处理大数问题

```java
class Solution {
    public int[] printNumbers(int n) {
        int m = (int)Math.pow(10, n) - 1;
        int[] res = new int[m];
        for (int i = 1; i <= m; i++) {
            res[i-1] = i;
        }
        return res;
    }
}
```

### 方法二：DFS+全排列

```java
char[] num, loop = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
StringBuilder sb = new StringBuilder();

public String printNumber(int len) {
    num = new char[len];
    for (int i = 1; i <= len; i++) {
        dfs(0, i);
    }
    return sb.deleteCharAt(sb.length() - 1).toString();
}

public void dfs(int index, int len) {
    if (index == len) {
        sb.append(new String(num) + ",");
        return;
    }
    int start = 0;

    //1.当num的下标index是0时，则loop从下标1开始进行全排列
    //2. 当num的下标index非0时，则loop从下标0开始进行全排列
    if (index == 0) {
        start = 1;
    } else {
        start = 0;
    }
    for (int i = start; i < 10; i++) {
        num[index] = loop[i];
        dfs(index + 1, len);
    }
}
```

```java
class Solution {
    char[] loop = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    char[] num;
    int[] res;
    int count;
    public int[] printNumbers(int n) {
        num = new char[n];
        res = new int[(int)Math.pow(10, n) - 1];
        for (int i = 1; i <= n; i++) {
            dfs(0, i);
        }
        return res;
    }

    public void dfs(int index, int len) {
        if (index == len) {
            String s = String.valueOf(num).trim();
            res[count++] = Integer.parseInt(s);
            return ;
        }
        int start = 0;
        if (index == 0) {
            start = 1;
        } 
        for (int i = start; i < loop.length; i++) {
            num[index] = loop[i];
            dfs(index + 1, len);
        }
    }
}
```




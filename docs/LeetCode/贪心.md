<!-- GFM-TOC -->

- [LeetCode 45 跳跃游戏II](#LeetCode-45-跳跃游戏II)
- [Offer 14. 剪绳子I](#Offer-14-剪绳子I)
- [Offer 14. 剪绳子II](#Offer-14-剪绳子II)

<!-- GFM-TOC -->

# LeetCode 45 跳跃游戏II

- 双指针 + 贪心 + dp
  - 时间复杂度：每个位置最多被扫描两次（同时被$i$和$j$经过），复杂度为$O(n)$

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] f = new int[n]; 
        for (int i = 1, j = 0; i < n; i++) {
            while (j + nums[j] < i) j++;
            f[i] = f[j] + 1;
        }
        return f[n - 1];
    }
}
```

# Offer 14. 剪绳子I

## 方法一：贪心

- 核心思路是：**尽可能把绳子分成长度为3的小段，这样乘积最大**
  - [证明](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/)

- 步骤如下：
  - 如果 n == 2，返回1
  - 如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1
  - 如果 n == 4，返回4
  - 如果 n > 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段
    以上2和3可以合并

```java
class Solution {
    public int cuttingRope(int n) {
        if(n < 4){
            return n - 1;
        }
        int res = 1;
        while(n > 4){
            res *= 3;
            n -= 3;
        }
        return res * n;
    }
}
```

## 方法二：动态规划

- 状态定义：$dp[i]$表示长度为`i`的绳子剪成`m`段后的最大乘积
- 初始条件：$dp[2] = 1$
- 状态转移：$dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))$

```java
class Solution {
    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for(int i = 3; i < n + 1; i++){
            for(int j = 2; j < i; j++){
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
```

# Offer 14. 剪绳子II

- 动态规划会有数据溢出问题

```java
class Solution {
    public int cuttingRope(int n) {
        if (n < 4) {
            return n - 1;
        }
        long res = 1;
        while (n > 4) {
            res = res * 3 % 1000000007;
            n -= 3;
        }
        return (int)(res * n % 1000000007);
    }
}
```


> **CPU缓存的作用：**是为了解决CPU跟内存之间数据传输速度不匹配的问题
>
> **虚拟内存的作用：**是为了解决计算机在运行较大的程序时内存不足的情况
>
> **物理内存=运行内存**
>
> 就是指计算机的安装内存“通俗的讲就是内存条的大小”
>
> **虚拟内存**指的是把硬盘中的一部分空间用来当做内存使用。
>
> 虚拟内存可以自己通过操作系统设置虚拟内存的大小。

# 1. 页表的工作原理

> 页表是一种特殊的[数据结构](https://baike.baidu.com/item/数据结构/1450)，放在系统空间的页表区，存放逻辑页与物理页帧的对应关系。 每一个[进程](https://baike.baidu.com/item/进程/382503)都拥有一个自己的页表，[PCB](https://baike.baidu.com/item/PCB/16067368)表中有指针指向页表
>
> 实现从页号到物理块号的地址映射

页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）

<img src="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.assets/image-20211028230812299.png" alt="image-20211028230812299" style="zoom:50%;" />

1. 假设cpu想访问虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第三条的值判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回

2. 若有效位为0，参数缺页异常，**调用内核缺页异常处理程序**。内核通过**页面置换算法**选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容

3. 缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1
4. 将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束
   

# 2. 为什么要有虚拟内存？

在还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是$2^32$也就是4G。并且这是固定的，**如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题**：

- 因为物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然要是内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的
- 由于指令都是直接访问物理内存的，那么进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的
- 因为内存是随机分配的，所以程序运行的地址也是不正确的

综上，虚拟内存应运而生！

# 3. 虚拟内存是怎么工作的

- 当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，**只是建立好虚拟内存和磁盘文件之间的映射就好**（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生**缺页异常**，于是将磁盘上的数据拷贝到物理内存中

- 另外在进程运行过程中，要通过`malloc`来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常

- 可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

<img src="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.assets/image-20211028231734040.png" alt="image-20211028231734040" style="zoom:50%;" />

# 4. 虚拟内存机制的优点 

- 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系

- 当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存

- 在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用物理内存

# 5. 虚拟内存与物理内存的联系

<img src="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.assets/image-20211028230636703.png" alt="image-20211028230636703" style="zoom:50%;" />

1. 每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址

2. 所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上

3. 进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录

4. 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）

5. 当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常

6. 缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘

# Reference

- [虚拟内存与物理内存的联系与区别](https://blog.csdn.net/lvyibin890/article/details/82217193)
- [物理内存，运行内存，虚拟内存有什么区别](https://www.zhihu.com/question/25659063/answer/722820860)
- [虚拟内存与物理内存的区别](https://blog.csdn.net/u012861978/article/details/53048077)
# 进程

进程是操作系统进行**资源分配和调度**的一个**独立单位**，进程一般由**程序、数据和进程控制块**(Program Control Block, PCB)，具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。

<center><img src="http://static.oschina.net/uploads/space/2015/0529/132501_6PVU_1863332.jpg"/></center>

【进程间通信（IPC）】：

- 管道(Pipe)
- 命名管道(FIFO)
- 消息队列(Message Queue) 
- 信号量(Semaphore) 
- 共享内存（Shared Memory）
- 套接字（Socket）

# 线程

线程是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（**Lightweight Process，LWP**）（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性)；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。

一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

<center><img src="https://static.oschina.net/uploads/space/2015/0529/133750_ldwM_1863332.jpg"/></center>

# 进程与线程的区别

- 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位;一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线;
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见;
- 调度和切换：线程上下文切换比进程上下文切换要快得多。
- 系统开销︰创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境，而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，同一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。

# 协程

协程，，英文Coroutines，是一种**比线程更加轻量级的存在**，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。这种**由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』**，具有对内核来说不可见的特性。

**协程的目的**

在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑(包括事务)。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态(等待该线程执行完才能执行），造成了资源应用不彻底。

最常见的例子就是JDBC(它是同步阻塞的)，这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。

对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调

而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。

**协程的特点**

线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。

线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。

由于在同一个线程上，因此可以避免竞争关系而使用锁。

适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。

**协程的原理**

当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉(主动让出)，并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。

由于协程的暂停完全由程序控制，发生在用户态上;而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。

因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。

**协程和线程的比较**

比较项线程协程占用资源初始单位为1MB,固定不可变初始一般为2KB，可随需要而增大调度所属由OS的内核完成由用户完成切换开销涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等只有三个寄存器的值修改–PC / SP / DX.性能问题资源占用太高，频繁创建销毁会带来严重的性能问题资源占用小,不会带来严重的性能问题数据同步需要用锁等机制确保数据的一直性和可见性不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

# Reference

- [一文读懂什么是进程、线程、协程](http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml)
- [进程、线程和协程之间的区别和联系](https://blog.csdn.net/daaikuaichuan/article/details/82951084)








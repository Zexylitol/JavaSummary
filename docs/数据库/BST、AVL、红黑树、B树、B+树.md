# BST：不平衡

二叉查找树(BST，Binary Search Tree)，也叫二叉排序树，在二叉树的基础上需要满足：任意节点的左子树上所有节点值不大于根节点的值，任意节点的右子树上所有节点值不小于根节点的值



<center><img src="https://ss.im5i.com/2021/09/12/fM8JO.png" alt="fM8JO.png" border="0" /></center>

查询时间取决于树高，平均时间复杂度是$O(logn)$。但是BST可能退化为链表，时间复杂度退化为$O(n)$。因此，引入了平衡二叉树

<center><img src="https://ss.im5i.com/2021/09/12/fMAoR.png" alt="fMAoR.png" border="0" /></center>



# AVL：旋转耗时

AVL(Self-balancing binary search tree)树是<span style="color:red">严格的平衡二叉树</span>，所有节点的左右子树高度差不能超过1；AVL树查找、插入和删除在平均和最坏情况下都是$O(logn)$。

AVL实现平衡的关键在于**旋转**操作：插入和删除可能破坏二叉树的平衡，此时需要通过一次或多次树旋转来重新平衡这个树。当插入数据时，最多只需要1次旋转(单旋转或双旋转)；但是当删除数据时，会导致树失衡，AVL需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的量级为$O(logn)$。

**由于旋转的耗时，AVL树在删除数据时效率很低**；在删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。

<span style="color:blue">AVL树适合于插入删除次数比较少，但查找多的情况</span>

**局限性**

由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，**如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树**。

# 红黑树：树太高

与AVL树相比，红黑树（Red Black Tree）并不追求严格的平衡，而是大致的平衡，是一种<span style="color:red">弱平衡</span>：通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。

<center><img src="https://ss.im5i.com/2021/09/12/fMLOd.png" alt="fMLOd.png" border="0" /></center>

**与AVL树相比，红黑树的查询效率会有所下降**，这是因为树的**平衡性变差，高度更高**。但红黑树的删除效率大大提高了，因为红黑树同时引入了颜色，当插入或删除数据时，只需要进行$O(1)$次数的旋转以及变色就能保证基本的平衡，不需要像AVL树进行$O(logn)$次数的旋转。总的来说，红黑树的统计性能高于AVL。

因此，在实际应用中，AVL树的使用相对较少，而红黑树的使用非常广泛。例如，Java中的TreeMap使用红黑树存储排序键值对；Java8中的HashMap使用链表+红黑树解决哈希冲突问题(当冲突节点较少时，使用链表，当冲突节点较多时，使用红黑树)。

对于数据在内存中的情况（如上述的TreeMap和HashMap），红黑树的表现是非常优异的。但是**对于数据在磁盘等辅助存储设备中的情况（如MySQL等数据库），红黑树并不擅长，因为红黑树长得还是太高了**。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能

**应用**

1. 广泛用于C++的STL中，Map和Set都是用红黑树实现的； 
2. 著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 
3. IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 
4. Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 
5. Java中TreeMap的实现；

# B树：为磁盘而生

B树也称B-树，是**为磁盘等辅存设备设计的多路平衡查找树**，与二叉树相比，B树的每个非叶节点可以有多个子树。因此，当总节点数量相同时，**B树的高度远远小于AVL树和红黑树(B树是一颗“矮胖子”)，磁盘IO次数大大减少**。

定义B树最重要的概念是阶数(Order)，对于一颗m阶B树，需要满足以下条件：

- 每个节点最多包含 m 个子节点。
- 如果根节点包含子节点，则至少包含 2 个子节点；除根节点外，每个非叶节点至少包含 m/2 个子节点。
- 拥有 k 个子节点的非叶节点将包含 k - 1 条记录。
- **所有叶节点都在同一层中**。

可以看出，B树的定义，主要是对非叶结点的子节点数量和记录数量的限制。

<center><img src="https://ss.im5i.com/2021/09/12/fM0XW.png" alt="fM0XW.png" border="0" /></center>

B树的优势除了树高小，还有对访问**局部性原理的利用**。所谓局部性原理，是指当一个数据被使用时，其附近的数据有较大概率在短时间内被使用。**B树将键相近的数据存储在同一个节点**，当访问其中某个数据时，数据库会将该整个节点读到缓存中；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO；换句话说，**B树的缓存命中率更高**。

# B+树

B+树也是多路平衡查找树，其与B树的区别主要在于：

- B树中每个节点（包括叶节点和非叶节点）都存储真实的数据，**B+树中只有叶子节点存储真实的数据，非叶节点只存储键**。在MySQL中，这里所说的真实数据，可能是行的全部数据（如Innodb的聚簇索引），也可能只是行的主键（如Innodb的辅助索引），或者是行所在的地址（如MyIsam的非聚簇索引）。
- B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复重现—一定会在叶节点出现，也可能在非叶节点重复出现。
- **B+树的叶节点之间通过双向链表链接**。
- B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同。

由此，B+树与B树相比，有以下优势：

- **更少的IO次数：**B+树的非叶节点只包含键，而不包含真实数据，**因此每个节点存储的记录个数比B数多很多**（即阶m更大），因此**B+树的高度更低，访问时所需要的IO次数更少**。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
- **更适于范围查询：**在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。
- **更稳定的查询效率：**B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。

B+树也存在劣势：由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛。

<center><img src="https://ss.im5i.com/2021/09/12/fMzd4.png" alt="fMzd4.png" border="0" /></center>

## B+树的威力

前面说到，B树/B+树与红黑树等二叉树相比，**最大的优势在于树高更矮**。实际上，对于Innodb的B+索引来说，树的高度一般在2-4层。下面来进行一些具体的估算。

树的高度是由阶数决定的，阶数越大树越矮；而阶数的大小又取决于每个节点可以存储多少条记录。Innodb中每个节点使用一个页(page)，页的默认大小为16KB，其中元数据只占大约128字节左右(包括文件管理头信息、页面头信息等等)，大多数空间都用来存储数据。

- 对于非叶节点，记录只包含索引的键和指向下一层节点的指针。假设每个非叶节点页面存储1000条记录，则每条记录大约占用16字节；当索引是整型或较短的字符串时，这个假设是合理的。延伸一下，经常听到建议说索引列长度不应过大，原因就在这里：**索引列太长，每个节点包含的记录数太少，会导致树太高，索引的效果会大打折扣，而且索引还会浪费更多的空间**。
- 对于叶节点，记录包含了索引的键和值(值可能是行的主键、一行完整数据等)，数据量更大。这里假设每个叶节点页面存储100条记录(实际上，当索引为聚簇索引时，这个数字可能不足100；当索引为辅助索引时，这个数字可能远大于100；可以根据实际情况进行估算)。

对于一颗3层B+树，第一层(根节点)有1个页面，可以存储1000条记录；第二层有1000个页面，可以存储$1000 \times 1000$条记录；第三层(叶节点)有个$1000 \times 1000$页面，每个页面可以存储100条记录，因此可以存储$1000 \times 1000 \times 100$条记录，即1亿条。而对于二叉树，存储1亿条记录则需要26层左右。

# 小结

1)    二叉查找树(BST)：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表；

2)    平衡二叉树(AVL)：通过旋转解决了平衡的问题，但是旋转操作效率太低；

3)    红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多；

4)    B树：通过将二叉树改为多路平衡查找树，解决了树过高的问题；

5)    B+树：在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。

# Reference

- [MySQL的索引结构为什么使用B+树？](https://www.cnblogs.com/kismetv/p/11582214.html)
- [为什么MySQL数据库索引选择使用B+树？](https://www.cnblogs.com/tiancai/p/9024351.html)


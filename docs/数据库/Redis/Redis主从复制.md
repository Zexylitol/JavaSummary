# 互联网三高架构

- 高并发
- 高性能
- 高可用

# 单机Redis的风险与问题

## 问题1：机器故障

- 现象：硬盘故障、系统崩溃
- 本质：数据丢失，很可能对业务造成灾难性打击

## 问题2：容量瓶颈

- 现象：内存不足，无限升级内存
- 本质：穷，硬件条件跟不上

## 结论

- 为了避免单点Redis服务器故障，准备多台服务器，互相连通，将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是<span style="color:red">同步</span>的
- 即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据<span style="color:red">冗余备份</span>

# 多台服务器连接方案

- 提供数据方：master/主节点/主库/主服务端
- 接收数据方：slave/从节点/从库/从服务器
- 需要解决的问题：数据同步
- 核心工作：master的数据复制到slave中

<center><img src="https://ss.im5i.com/2021/07/30/Go3fl.png" alt="Go3fl.png" border="0" /></center>

# 主从复制

## 简介

- 主从复制即将master中的数据即时、有效的复制到slave中
- 特征：一个master可用用于多个slave，一个slave只对应一个master
- 职责：
  - master：
    - 写数据
    - 执行写操作时，将出现变化的数据自动同步到slave
    - 读数据（可忽略）
  - slave：
    - 读数据
    - 写数据（禁止）

## 作用

- 读写分离：master写、slave读，提高服务器的读写负载能力

- 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量

- 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复

- 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式

- 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案

# Redis主从复制

Redis具有高可靠性的两层含义：

- 数据尽量少丢失，由AOF和RDB保证
- 服务尽量少中断，通过增加副本冗余量，将一份数据同时保存在多个实例上

Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式：

- 读操作：主库、从库都可以接收
- 写操作：首先到主库执行，然后，主库将写操作同步给从库

<center><img src="https://ss.im5i.com/2021/07/31/GoIX7.png" alt="GoIX7.png" border="0" /></center>

主从库模式一旦采用了读写分离，所有数据的修改只会在主库上进行，不用协调三个实例，主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的

## 主从库间如何进行第一次同步？

当启动多个Redis实例的时候，它们相互之间就可以通过`replicaof` (Redis 5.0之前使用`slaveof`)命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。

例如，现在有实例1 (ip: 172.16.19.3) 和实例2 (ip: 172.16.19.5) ，在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：

```squirrel
replicaof 172.16.19.3 6379
```



<center><img src="https://ss.im5i.com/2021/07/31/GoZD2.png" alt="GoZD2.png" border="0" /></center>

**第一阶段:**

**主从库间建立连接、协商同步的过程**，主要是为**全量复制**做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。

具体来说，从库给主库发送`psync`命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。`psync` 命令包含了主库的`runID`和复制进度`offset`两个参数。

- `runID`，每个Redis实例启动时都会自动生成的一个随机ID，用来**唯一标记这个实例**。当从库和主库第一次复制时，因为不知道主库的`runID`，所以将`runID`设为"?"

- offset，此时设为$-1$，表示第一次复制

主库收到`psync`命令后，会用`FULLRESYNC`响应命令带上两个参数：主库`runID`和主库目前的复制进度`offset`，返回给从库。从库收到响应后，会记录下这两个参数

<span style="color:red">`FULLRESYNC` 响应表示第一次复制采用的全量复制</span>，也就是说，主库会把当前所有的数据都复制给从库

**第二阶段：**

**主库将所有数据同步给从库**。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的RDB文件。

具体来说，主库执行`bgsave`命令，生成RDB文件，接着将文件发给从库。从库接收到RDB文件后，先清空当前数据库，然后加载RDB文件。这是因为从库在通过`replicaof`命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。

**在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求**。否则，Redis的服务就被中断了。<span style="color:red">但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性， 主库会在内存中用专门的`replication buffer`，记录RDB文件生成后收到的所有写操作</span>。

**第三个阶段：**

**主库会把第二阶段执行过程中新收到的写命令，再发送给从库**。具体的操作是，当主库完成RDB文件发送后，就会把此时`replication buffer`中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

## 主从级联模式分担全量复制时的主库压力

通过分析主从库间第一次数据同步的过程，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<span style="color:green">生成RDB文件和传输RDB文件</span>。

**如果从库数量很多，而且都要和主库进行全量复制的话**，就会导致主库忙于fork子进程生成RDB文件，进行数据全量同步。fork这个操作会阻塞主线程处理正常请求，**从而导致主库响应应用程序的请求速度变慢**。此外，**传输RDB文件也会占用主库的网络带宽**，同样会给主库的资源使用带来压力。那么，<span style="color:red">可以采用"主-从-从"模式分担主库压力</span>

在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，**可以通过“主-从-从"模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上**。

简单来说，在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库)，用于级联其他的从库。然后，可以再选择一些从库（例如三分之一的从库)，在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系：

```squirrel
replicaaof 所选从库的IP 6379
```

这样一来，这些从库在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这样可以减轻主库上的压力，如下图所示：

<center><img src="https://ss.im5i.com/2021/07/31/GomgP.png" alt="GomgP.png" border="0" /></center>

一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。

但是如果**网络断连或阻塞**，主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持—致了，客户端就可能从从库读到旧数据。

## 主从库网络断了怎么办？

在Redis 2.8之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。

从 Redis 2.8开始，网络断了之后，主从库会采用**增量复制**的方式继续同步。全量复制是同步所有数据，而**增量复制只会把主从库网络断连期间主库收到的命令，同步给从库**。

<span style="color:blue">增量复制时，主从库之间是通过`repl_backlog_buffer`这个缓冲区实现增量命令的同步的</span>

当主从库断连后，主库会把断连期间收到的写操作命令，写入`replication buffer`，同时也会把这些操作命令也写入`repl_backlog_buffer`这个缓冲区。

`repl_backlog_buffer`是一个环形缓冲区，**主库会记录自己写到的位置，从库则会记录自己已经读到的位置。**

刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是`master_repl_offset`。主库接收的新写操作越多，这个值就会越大。

同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量`slave_repl_offset`也在不断增加。正常情况下，这两个偏移量基本相等。

<center><img src="https://ss.im5i.com/2021/07/31/GoxuD.png" alt="GoxuD.png" border="0" /></center>

主从库的连接恢复之后，从库首先会给主库发送`psync`命令，并把自己当前的
`slave_repl_offset`发给主库，主库会判断自己的`master_repl_offset`和`slave_repl_offset` 之间的差距。
在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，`master_repl_offset`会大于`slave_repl_offset`。此时，主库只用把 `master_repl_offset`和`slave_repl_offset`之间的命令操作同步给从库就行。
就像刚刚示意图的中间部分，主库和从库之间相差了`put d e`和`put d f`两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。

<span style="color:red">增量复制流程如下图所示：</span>

<center><img src="https://ss.im5i.com/2021/07/31/Go88j.png" alt="Go88j.png" border="0" /></center>

因为`repl_backlog_buffer`是一个环形缓冲区，所以**在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。**

因此，要想办法避免这一情况，一般而言，可以调整`repl_backlog_size`这个参数。**这个参数和所需的缓冲空间大小有关**。缓冲空间的计算公式是：`缓冲空间大小=主库写入命令速度 x 操作大小 - 主从库间网络传输命令速度 x 操作大小`​。在实际应用中，考虑到可能存在一些突发的请求压力，通常需要把这个缓冲空间扩大一倍，即 `repl_backlog_size=缓冲空间大小*2`，这也就是`repl_backlog_size` 的最终值。

举个例子，如果主库每秒写入2000个操作，每个操作的大小为2KB，网络每秒能传输1000个操作，那么，有1000个操作需要缓冲起来，这就至少需要2MB的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，最终把`repl_backlog_size`设为4MB。

这样一来，**增量复制时主从库的数据不一致风险就降低了**。不过，如果并发请求量非常大，连两倍的缓冲空间都存不下新操作请求的话，此时，主从库数据仍然可能不一致。

针对这种情况，一方面，可以根据Redis所在服务器的内存资源再适当增加`repl_backlog_size`值，比如说设置成缓冲空间大小的4倍，另一方面，可以考虑使用**切片集群来分担单个主库的请求压力**。

## 为什么主从库间的复制不使用AOF？

- AOF文件比RDB文件大，网络传世比较耗时
- 从库在初始化数据时，RDB文件比AOF文件执行更快






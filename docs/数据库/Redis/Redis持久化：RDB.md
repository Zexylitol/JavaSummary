# 简介

内存快照（RDB, Redis DataBase）是Redis的另一种持久化方法。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会失，数据的可靠性也就得到了保证

<span style="color:red">和AOF相比，RDB记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，可以直接把RDB文件读入内存，很快地完成恢复</span>

内存快照也并不是最优选项，还要考虑两个关键问题：

- 对哪些数据做快照？这关系到快照的执行效率问题
- 做快照时，数据还能被增删改吗？这关系到Redis是否被阻塞，能否同时正常处理请求

# 给哪些内存数据做快照？

Redis的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<span style="color:red">全量快照</span>，也就是说，把内存中的所有数据都记录到磁盘中，这样做的好处是，一次性记录了所有数据，一个都不少。

给内存的全量数据做快照，把它们全部写入磁盘也会花费很多时间。全量数据越多，RDB文件就越大，往磁盘上写数据的时间开销就越大。

**对于Redis而言，它的单线程模型就决定了，要尽量避免所有会阻塞主线程的操作**，所以，针对任何操作，都会提一个灵魂之问: "它会阻塞主线程吗?" RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低Redis的性能。

Redis提供了两个命令来生成RDB文件，分别是save和bgsave。

- save：在主线程中执行，会导致阻塞
- bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis RDB文件生成的默认配置，既提供了数据的可靠性保证，也避免了对Redis的性能影响

# 快照时数据能修改吗？

举个例子。在时刻t给内存做快照，假设内存数据量是4GB，磁盘的写入带宽是0.2GB/s，简单来说，至少要20s (4/0.2= 20)才能做完。如果在时刻t+5s时，一个还没有被写入磁盘的内存数据A，被修改成了A'，那么就会破坏快照的完整性，因为A'不是时刻t时的状态。因此，**在做快照时也不希望数据被修改**

但是，如果快照执行期间数据不能被修改，是会有潜在问题的。对于刚刚的例子来说，在做快照的20s时间里，如果这4GB的数据都不能被修改，Redis 就不能处理对这些数据的写操作，那无疑就会给业务服务造成巨大的影响。

bgsave避免阻塞和正常处理写操作并不是一回事。此时，主线程的确没有阻塞，可以正常接收请求，但是，**为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据**

为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的<span style="color:red">写时复制技术(Copy-On-Write, COW)，在执行快照的同时，正常处理写操作</span>。

简单来说，bgsave 子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件。**写时复制机制保证快照期间数据可修改**

如果主线程对这些数据也都是读操作(例如图中的键值对A)， 那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据(例如图中的键值对C)，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

<center><img src="https://ss.im5i.com/2021/07/30/GW464.png" alt="GW464.png" border="0" /></center>

这样既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响

# 可以每秒做一次快照吗？

虽然bgsave执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：

- 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环

- bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是, fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。**如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了**

<span style="color:red">此时，可以做增量快照，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销</span>

在第一次做完全量快照后，T1和T2时刻如果再做快照，只需要将被修改的数据写入快照文件就行需要记住哪些数据被修改了，需要使用额外的**元数据信息**去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：

<center><img src="https://ss.im5i.com/2021/07/30/GWpbW.png" alt="GWpbW.png" border="0" /></center>

如果对每一个键值对的修改，都做个记录，那么，如果有1万个被修改的键值对，就需要有1万条额外的记录。而且，有的时候，键值对非常小，比如只有32字节，而记录它被修改的元数据信息，可能就需要8字节，**这样引入的额外空间开销比较大**。这对于内存资源宝贵的Redis来说，有些得不偿失。

<span style="color:red">虽然跟AOF相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销</span>

**Redis 4.0中提出了一个混合使用AOF日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。**

这样一来，快照不用很频繁地执行，这就避免了频繁fork对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1和T2时刻的修改，用AOF日志记录，等到第二次做全量快照时，就可以清空AOF日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

<center><img src="https://ss.im5i.com/2021/07/30/GW7mG.png" alt="GW7mG.png" border="0" /></center>

这个方法既能利用RDB的快速恢复，又能以较小的开销做到尽量少丢数据

# AOF vs RDB

- 数据不能丢失时，内存快照和AOF的混合使用是一个很好的选择

- 如果允许分钟级别的数据丢失，可以只使用RDB

- 如果只用AOF，优先使用everysec的配置选项，因为它在可靠性和性能之间取了一个平衡

<center><img src="https://ss.im5i.com/2021/07/30/GWOQz.png" alt="GWOQz.png" border="0" /></center>

# AOF 与 RDB选择之惑

- 对数据非常敏感，建议使用默认的AOF持久化方案
  - AOF持久化策略使用everysecond ，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。
  - 注意：由于AOF文件存储体积较大，且恢复速度较慢

- 数据呈现阶段有效性，建议使用RDB持久化方案
  - 数据可以良好的做到阶段内无丢失(该阶段是开发者或运维人员手工维护的)，且恢复速度较快，阶段点数据恢复通常采用RDB方案

- 综合比对
  - RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊
  - 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF
  - 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB
  - 灾难恢复选用RDB
  - 双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量

# Reference

- [Redis核心技术与实战](https://time.geekbang.org/column/intro/100056701?utm_source=geektime-web&utm_medium=pcditu&utm_campaign=100084301&utm_content=bottombanner&utm_term=pc_interstitial_1220)
# 1. Redis数据存储格式

- Redis自身是一个Map，其中所有的数据都是采用<span style="color:blue">key : value</span>的形式存储

- <span style="color:red">数据类型</span>指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串

<center><img src="https://ss.im5i.com/2021/07/19/gxjPG.png" alt="gxjPG.png" border="0" /></center>

# 2. 常用类型

|                | String                                                       | List                                                         | Set                                                          | SortedSet                                                    | Hash                                                         |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Java中的对应类 | Object类（任何对象都会序列化成String来存储）                 | java.util.List接口的实现类java.util.LinkedList               | java.util.Set接口                                            | java.util.SortedSet接口                                      | java.util.HashMap                                            |
| 简介           | **String类型是Redis中最为基础的数据存储类型**，是二进制安全的字符串，该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中String类型的Value最多可以容纳的数据长度是512M。对于其他的几种数据结构，只有String类型的命令在写入key的时候可以带有默认的过期时间。对于其他的数据结构，key默认是不过期的，如果需要设置过期时间，必须显示调用expire函数设置过期时间 | List类型是**按照插入顺序排序的字符串链表。和数据结构中的普通链表一样**，可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。从元素插入和删除的效率视角来看，如果是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 | **没有排序的字符串集合**，但和列表不同的是集合中**不允许有重复的元素**，并且集合中的元素是无序的，不能通过索引下标获取元素，Redis 除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。合理的使用好集合类型，能在实际开发中解决很多实际问题。 | SortedSet和Set类型极为相似，它们都是**字符串的集合**，都不允许重复的成员出现在一个Set中。主要差别是**SortedSet中的每一个成员都会有一个分数(score)与之关联**，Redis正是通过分数来为集合中的成员进行从小到大的排序。需要额外指出的是，尽管SortedSet中的成员必须是唯一的，但是**分数(score)却是可以重复的**。在**SortedSet中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为O(logn)**。由于SortedSet中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。 | 相当于Java中的HaspMap，非常适合于存储值对象的信息，比如User对象含有userName、Password和Age等属性，可以使用hash来存储User，每个field对应一个属性，好处是可以做到部分更新、获取。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间 |
| 使用场景       | 1. 借助incr/decr用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 2. 控制数据的生命周期，通过数据是否失效控制业务行为<br/>**缓存、计数器、共享 Session、限速** | **Redis 的 lpush + brpop 命令组合即可实现阻塞队列，生产者客户端是用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性** | 1. 跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息<br/>2. 如：一个用户对娱乐、体育比较感兴趣，另一个可能对新闻感兴趣，这些兴趣就是标签，有了这些数据就可以得到同一标签的人，以及用户的共同爱好的标签，这些数据对于用户体验以及曾强用户粘度比较重要 | 可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP TEN的用户信息。当然也可以利用ZRANK命令通过username来获取玩家的排行信息。最后将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。SortedSet类型还可用于构建索引数据。建立一个SortedSet中元素个数不要超过1W | 1. 对于海量数据的情况，可以自己对数据进行分桶，然后使用Hash结构来存储。2. 将对象存储为Hash结构而不是String，可以每次只更新、获取Hash中的一个field，这样可以提高效率 3. 购物车设计<br/>**哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于用户信息等管理** |

HyperLogLog

HyperLogLog类型用来进行基数统计。利用HyperLogLog，用户可以使用少量固定大小的内存，来统计集合中唯一元素的数量（每个HyperLogLog占用12KB内存，可以计算接近264个不同元素的基数）

利用HyperLogLog得到的基数统计结果，不是精确值，而是一个带有0.81%标准差（standard error）的近似值。所以，HyperLogLog适用于一些对于统计结果精确度要求不是特别高的场景。

使用场景：

1.可以用于统计一个网站的UV。利用HyperLogLog来统计访问一个网站的不同ip的个数

# 3. 常用类型存储格式

## 3.1 string

<center><img src="https://ss.im5i.com/2021/07/19/gxTjz.png" alt="gxTjz.png" border="0" /></center>

## 3.2 hash

<center><img src="https://ss.im5i.com/2021/07/19/gxWe5.png" alt="gxWe5.png" border="0" /></center>

## 3.3 list

底层采用双向链表

<center><img src="https://ss.im5i.com/2021/07/19/gx266.png" alt="gx266.png" border="0" /></center>

## 3.4 set

与hash存储结构完全相同，仅存储键，不存储值（nil），并且键是不允许重复的

<center><img src="https://ss.im5i.com/2021/07/19/gx9U8.png" alt="gx9U8.png" border="0" /></center>

## 3.5 sorted_set类型

在set的存储结构基础上添加可排序字段

<center><img src="https://ss.im5i.com/2021/07/19/gxRiU.png" alt="gxRiU.png" border="0" /></center>

# 4. 为什么Redis要用跳表实现有序集合

## 4.1 什么是跳表

二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗? 实际上，只需要对链表稍加改造，就可以支持类似"“二分"的查找算法。我们把改造之后的数据结构叫作**跳表(Skip list)**。

跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树(Red-black tree)。

<center><img src="https://ss.im5i.com/2021/08/26/fdvWs.png" alt="fdvWs.png" border="0" /></center>

**跳表：在原始链表基础上，每两个节点提取一个节点到上一级，把抽出来的那一级叫做索引或索引层**

<span style="color:red">跳表 = 链表 + 多级索引结构</span>

## 4.2 跳表的增删改查

在跳表中查询任意数据的时间复杂度为：$O(logn)$

跳表的空间复杂度：$O(n)$

跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是：$O(logn)$

## 4.3 跳表索引动态更新

**作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡**，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

红黑树是通过左右旋的方式保持左右子树的大小平衡，而**跳表是通过随机函数来维护前面提到的“平衡性**”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢?

我们**通过一个随机函数，来决定将这个结点插入到哪几级索引中**，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

## 4.3 Redis为什么用跳表而不是红黑树来实现有序集合

Redis中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。如果你去查看Redis的开发手册，就会发现，Redis中的有序集合支持的核心操作主要有下面这几个：

- 插入一个数据
- 删除一个数据
- 查找一个数据
- 按照区间查找数据（比如查找值在[100,356]之间的数据)
- 迭代输出有序序列

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，**按照区间来查找数据这个操作，红黑树的效率没有跳表高**。

对于按照区间查找数据这个操作，跳表可以做到$O(logn)$的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

当然，Redis之所以用跳表来实现有序集合，还有其他原因，**比如，跳表更容易代码实现**。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的MaP类型都是通过红黑树来实现的。做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

## 4.4 小结

**跳表使用空间换时间的设计思路**，通过构建多级索引来提高查询的效率，实现了基于链表的"二分查找”跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是$O(logn)$。

跳表的空间复杂度是$O(n)$。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。







 
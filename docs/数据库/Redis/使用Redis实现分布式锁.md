# 前言

在分布式系统中，当有多个客户端需要获取锁时，需要分布式锁。此时，锁是保存在一个**共享存储系统**中的，可以被多个客户端共享访问和获取。

Redis本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且Redis的读写性能高，可以应对高并发的锁操作场景

## 分布式锁的约束条件

|  特点  | 描述                                                         |
| :----: | :----------------------------------------------------------- |
| 互斥性 | 即：在任意时刻，只有一个客户端能持有锁                       |
| 安全性 | 即：不会出现死锁的情况，当一个客户端在持有锁期间内，由于意外崩溃而导致锁未能主动解锁，<br>其持有的锁也能够被正确释放，并保证后续其它客户端也能加锁； |
| 可用性 | 即：分布式锁需要有一定的故障恢复能力，通过高可用机制能够保证故障发生的情况下能够最大限度对外提供服务，<br>无单点风险。如:通过Redis的集群模式、哨兵模式；ETCD/zookeeper的集群选主能力等保证HA |
| 对称性 | 对于任意一个锁，其加锁和解锁必须是同一个客户端，即客户端 A 不能把客户端 B 加的锁给解了。这又称为锁的可重入性。 |

## 分布式锁常见实现方式

| 类别                             | 举例                                                         |
| :------------------------------- | :----------------------------------------------------------- |
| 通过数据库方式实现               | 如：采用乐观锁、悲观锁或者基于主键唯一约束实现               |
| 基于分布式缓存实现的锁服务       | 如： Redis 和基于 Redis 的 RedLock（红锁，Redisson提供了参考实现） |
| 基于分布式一致性算法实现的锁服务 | 如：ZooKeeper、Chubby（google闭源实现） 和 Etcd              |



# 单机上的锁和分布式锁的联系与分别

对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示：

- 变量值为0时，表示没有线程获取锁
- 变量值为1时，表示已经有线程获取到锁

和单机上的锁类似，分布式锁同样可以**用一个变量来实现**。客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：**加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为0，表明客户端不再持有锁**。

但是，<span style="color:green">和线程在单机上操作锁不同的是，在分布式场景下，锁变量需要由一个共享存储系统来维护</span>，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，**加锁和释放锁的操作就变成了<span style="color:blue">读取、判断和设置</span>共享存储系统中的锁变量值**。

**实现分布式锁的两个要求：**

- 要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，**需要保证这些锁操作的原子性**；
- 要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，需要考虑**保证共享存储系统的可靠性，进而保证锁的可靠性**

# 基于单个Redis节点实现分布式锁

要保证Redis操作的原子性，有两种通用的方法，分别是使用Redis的单命令操作和使用Lua脚本

## SETNX和DEL命令组合 + Lua脚本实现分布式锁

### SET命令

```
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

- `EX second` ：设置键的过期时间为 `second` 秒。 `SET key value EX second` 效果等同于 `SETEX key second value` 。
- `PX millisecond` ：设置键的过期时间为 `millisecond` 毫秒。 `SET key value PX millisecond` 效果等同于 `PSETEX key millisecond value` 。
- `NX` ：只在键不存在时，才对键进行设置操作。 `SET key value NX` 效果等同于 `SETNX key value` 。
- `XX` ：只在键已经存在时，才对键进行设置操作。

>  因为 [*SET*](http://doc.redisfans.com/string/set.html#set) 命令可以通过参数来实现和 [*SETNX*](http://doc.redisfans.com/string/setnx.html#setnx) 、 [*SETEX*](http://doc.redisfans.com/string/setex.html#setex) 和 [*PSETEX*](http://doc.redisfans.com/string/psetex.html#psetex) 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 [*SETNX*](http://doc.redisfans.com/string/setnx.html#setnx) 、 [*SETEX*](http://doc.redisfans.com/string/setex.html#setex) 和 [*PSETEX*](http://doc.redisfans.com/string/psetex.html#psetex) 这三个命令。

### 分布式锁实现

`SETNX`命令在执行时，如果要设置的键值对（也就是锁变量）不存在，`SETNX`命令会先创建键值对，然后设置它的值。所以，释放锁之后(即使用`DEL`命令删除锁变量)，再有客户端请求加锁时，`SETNX`命令会创建保存锁变量的键值对，并设置锁变量的值，完成加锁。就可以用`SETNX`和`DEL`命令组合来实现加锁和释放锁操作，伪代码：

```
// 加锁
SETNX lock_key 1
// 业务逻辑
DO THINGS
// 释放锁
DEL lock_key
```

### 存在风险及解决办法

使用`SETNX`和`DEL`命令组合实现分布锁，存在两个潜在的风险。

风险一：

假如某个客户端在执行了`SETNX`命令、加锁之后，紧接着却在操作共享数据时发生了异常，结果一直没有执行最后的`DEL`命令释放锁。因此，锁就一直被这个客户端持有，其它客户端无法拿到锁，也无法访问共享数据和执行后续操作，这会给业务应用带来影响。

针对这个问题，一个有效的解决方法是，**给锁变量设置一个过期时间**。这样一来，即使持有锁的客户端发生了异常，无法主动地释放锁，Redis也会根据锁变量的过期时间，在锁变量过期后，把它删除。其它客户端在锁变量过期后，就可以重新请求加锁，这就不会出现无法加锁的问题了。

风险二：

如果客户端A执行了`SETNX`命令加锁后，假设客户端B执行了`DEL`命令释放锁，此时，客户端A的锁就被误释放了。如果客户端C正好也在申请加锁，就可以成功获得锁，进而开始操作共享数据。这样一来，客户端A和C同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。

为了应对这个问题，需要**能区分来自不同客户端的锁操作**，可以在锁变量的值上想办法

在使用`SETNX`命令进行加锁的方法中，通过把锁变量值设置为1或0，表示是否加锁成功。1和0只有两种状态，无法表示究竟是哪个客户端进行的锁操作。所以，**在加锁操作时，可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当前操作的客户端**。在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题了

在加锁操作中，每个客户端都使用了一个唯一标识，所以在释放锁操作时，需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下所示：

```
//释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

这是使用Lua脚本（unlock.script）实现的释放锁操作的伪代码，其中，`KEYS[1]`表示`lock_key`，`ARGV[1]`是当前客户端的唯一标识，这两个值都是在执行Lua脚本时作为参数传入的。

最后，执行下面的命令，就可以完成锁释放操作了。

```
redis-cli  --eval  unlock.script lock_key , unique_value 
```

<span style="color:blue">在释放锁操作中，使用了Lua脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而Redis在执行Lua脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性</span>。

## 小结

现在只用了一个Redis实例来保存锁变量，如果这个Redis实例发生故障宕机了，那么锁变量就没有了。此时，客户端也无法进行锁操作了，这就会影响到业务的正常执行

# 基于多个Redis节点实现高可靠的分布式锁

当要实现高可靠的分布式锁时，就不能只依赖单个的命令操作了，需要按照一定的步骤和规则进行加解锁操作，否则，就可能会出现锁无法工作的情况。**“一定的步骤和规则”其实就是分布式锁的算法**

为了避免Redis实例故障而导致的锁无法工作的问题，Redis的开发者Antirez提出了**分布式锁算法Redlock**。

Redlock算法的基本思路，是让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个Redis实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。

Redlock算法的实现需要有N个独立的Redis实例。可以分成3步来完成加锁操作：

**第一步：客户端获取当前时间。**

**第二步：客户端按顺序依次向N个Redis实例执行加锁操作。**

这里的加锁操作和在单实例上执行的加锁操作一样，使用SET命令，带上NX，EX/PX选项，以及带上客户端的唯一标识。当然，如果某个Redis实例发生故障了，为了保证在这种情况下，Redlock算法能够继续运行，需要给加锁操作设置一个超时时间。

如果客户端在和一个Redis实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个Redis实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。

**第三步：一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁过程的总耗时。**

客户端只有在满足下面的这两个条件时，才能认为是加锁成功。

- 条件一：客户端从超过半数（大于等于 N/2+1）的Redis实例上成功获取到了锁；
- 条件二：客户端获取锁的总耗时没有超过锁的有效时间。

在满足了这两个条件后，需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。

当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有Redis节点发起释放锁的操作。

在Redlock算法中，释放锁的操作和在单实例上释放锁的操作一样，**只要执行释放锁的Lua脚本就可以了**。这样一来，只要N个Redis实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。

所以，在实际的业务应用中，想要提升分布式锁的可靠性，可以通过Redlock算法来实现。

# 总结

**分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作**。Redis作为一个共享存储系统，可以用来实现分布式锁。

在基于单个Redis实例实现分布式锁时，对于加锁操作，需要满足三个条件。

1. **加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作**，但需要以原子操作的方式完成，所以，使用`SET`命令带上`NX`选项来实现加锁；
2. 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，在`SET`命令执行时加上`EX/PX`选项，设置其过期时间；
3. 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，使用`SET`命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。

和加锁类似，**释放锁也包含了读取锁变量值、判断锁变量值和删除锁变量三个操作**，不过，无法使用单个命令来实现，所以，可以采用Lua脚本执行释放锁操作，通过Redis原子性地执行Lua脚本，来保证释放锁操作的原子性。

**基于单个Redis实例实现分布式锁时，会面临实例异常或崩溃的情况，这会导致实例无法提供锁操作**，正因为此，Redis也提供了Redlock算法，用来实现基于多个实例的分布式锁。这样一来，锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。Redlock算法是实现高可靠分布式锁的一种有效解决方案。



# 对比

## 基于数据库分布式锁实现

优点：直接使用数据库，实现方式简单

缺点：

- DB操作性能较差，并且有锁表的风险
- 非阻塞操作失败后，需要轮询，占用CPU资源
- 长时间不`commit`或者长时间轮询，可能会占用较多连接资源

## 基于Redis实现

1. set px nx + 唯一id + Lua脚本

优点：redis本身的读写性能很高，因此基于redis的分布式锁效率比较高

缺点：依赖中间件，分布式环境下可能会有节点数据同步问题，可靠性有一定的影响

2. redlock

优点：可以解决Redis集群的同步可用性问题

缺点：

- 依赖中间件，维护成本高，需要多个独立的master节点，需要同时对多个节点申请锁，降低了一些效率
- 锁删除失败，过期时间不好控制
- 非阻塞，操作失败后，需要轮询，占用CPU资源

## 基于zookeeper的分布式锁

优点：不存在redis的超时、数据同步（zookeeper是同步完以后才返回）、主从切换（zookeeper主从切换的过程中服务是不可用的）的问题，可靠性很高

缺点：依赖中间件，保证了可靠性的同时牺牲了一部分效率（但是依然很高）。性能不如redis。

## 小结

1. 从理解的难易程度角度（从低到高）数据库 > 缓存 > Zookeeper
2. 从实现的复杂性角度（从低到高）Zookeeper >= 缓存 > 数据库
3. 从性能角度（从高到低）缓存 > Zookeeper >= 数据库
4. 从可靠性角度（从高到低）Zookeeper > 缓存 > 数据库

没有绝对完美的实现方式，具体要选择哪一种分布式锁，需要结合每一种锁的优缺点和业务特点而定。

# Reference

- [常用的分布式锁](https://www.cnblogs.com/owenma/p/12355262.html)


























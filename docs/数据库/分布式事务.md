# 本地事务

本地事务：在分布式系统，只能控制住自己的回滚，控制不了其他服务的回滚

在以往的单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易的整体回滚；

### 事务的传播行为

1、`PROPAGATION_REQUIRED`：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2、`PROPAGATION_SUPPORTS`：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

3、`PROPAGATION_MANDATORY`：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4、`PROPAGATION_REQUIRES_NEW`：创建新事务，无论当前存不存在事务，都创建新事务。

5、`PROPAGATION_NOT_SUPPORTED`：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6、`PROPAGATION_NEVER`：以非事务方式执行，如果当前存在事务，则抛出异常。

7、`PROPAGATION_NESTED`：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与`PROPAGATION_REQUIRED`类似的操作。

> 事务是通过AOP切面执行的，同一个类内方法互相调用切面无效
>
> 同一个对象内事务方法互调默认失效，原因：绕过了代理对象
>
> 解决方案：使用代理对象来调用事务方法
>
> 1. 引入 aop-starter; spring-boot-starter-aop; 引入了 aspectj
> 2. @EnableAspectJAutoProxy，开启 aspectj 动态代理功能，以后所有的动态代理都是 aspectj 创建的（即使没有接口也可以创建动态代理）
> 3. @EnableAspectJAutoProxy(exposeProxy = true)：对外暴露代理对象
> 4. AopContext.currentProxy()：本类互调用

# 分布式事务

分布式事务：最大原因：网络问题

### 为什么有分布式事务

分布式系统经常出现的异常

机器宕机、网络异常、消息丢失、消息.乱序、数据错误、不可靠的TCP、存储数据丢失...

<center><img src="https://ss.im5i.com/2021/08/25/f6ykQ.png" alt="f6ykQ.png" border="0" /></center>

分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架中，几乎可以说是无法避免。

### CAP定理与BASE理论

####  CAP定理

CAP 理论是针对分布式数据库而言的，它是指在一个分布式系统中，一致性（Consistency, C）、可用性（Availability, A）、分区容错性（Partition Tolerance, P）三者不可兼得。

**一致性（C）**

一致性是指"all nodes see the same data at the same time"，**即更新操作成功后，所有节点在同一时间的数据完全一致**。

一致性可以分为客户端和服务端两个不同的视角：

- 从客户端角度来看，一致性主要指多个用户并发访问时更新的数据如何被其他用户获取的问题；
- 从服务端来看，一致性则是用户进行数据更新时如何将数据复制到整个系统，以保证数据的一致。


一致性是在并发读写时才会出现的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。

**可用性（A）**

可用性是指"reads and writes always succeed"，**即用户访问数据时，系统是否能在正常响应时间返回结果**。

好的可用性主要是指系统能够很好地为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。在通常情况下，可用性与分布式数据冗余、负载均衡等有着很大的关联。

**分区容错性（P）**

分区容错性是指"the system continues to operate despite arbitrary message loss or failure of part of the system"，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。**分区容错性高指在部分节点故障或出现丢包的情况下，集群系统仍然能提供服务，完成数据的访问**。分区容错可视为在系统中采用多副本策略。

**相互关系**

CAP 理论认为分布式系统只能兼顾其中的两个特性，即出现 CA、CP、AP 三种情况。

<center><img src="https://ss.im5i.com/2021/08/25/f6sDO.png" alt="f6sDO.png" border="0" /></center>

**CA without P**

如果不要求 Partition Tolerance，即不允许分区，则强一致性和可用性是可以保证的。其实分区是始终存在的问题，因此 CA 的分布式系统更多的是允许分区后各子系统依然保持 CA。

**CP without A**

如果不要求可用性，相当于每个请求都需要在各服务器之间强一致，而分区容错性会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。

**AP without C**

如果要可用性高并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了实现高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

##### Raft算法

分布式系统中实现一致性的raft算法

分布式一致性动画演示：http://thesecretlivesofdata.com/raft/

#### 面临的问题

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到99.99999%(N个9)，即保证P和A，舍弃C。

#### BASE理论

是对CAP理论的延伸，思想是即使无法做到强一致性(CAP的一致性就是强一致性），但可以采用适当的采取弱一

致性，即最终一致性。

BASE是指：

- 基本可用(Basically Available)
  - 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性）。需要注意的是，基本可用绝不等价于系统不可用
    - 响应时间上的损失：正常情况下搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了1- 2秒
    - 功能上的损失：购物网站在购物高峰(如双十一)时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面
- 软状态(Soft State)
  - 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现
- 最终一致性(Eventual Consistency)
  - 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况

#### 强一致性、弱一致性、最终一致性

从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是**强一致性**。如果能容忍后续的部分或者全部访问不到，则是**弱一致性**。如果经过一段时间后要求能访问到更新后的数据，则是**最终一致性**

# 柔性事务的定义与分类

## 柔性事务的定义

**刚性事务**（如单数据库）完全遵循 ACID 规范，即数据库事务正确执行的四个基本要素：

- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

**柔性事务**（如分布式事务）为了满足可用性、性能与降级服务的需要，降低一致性（Consistency）与隔离性（Isolation）的要求，遵循 BASE 理论：

- 基本业务可用性（Basic Availability）
- 柔性状态（Soft state）
- 最终一致性（Eventual consistency）

同样的，柔性事务也部分遵循 ACID 规范：

- 原子性：严格遵循
- 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽
- 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽
- 持久性：严格遵循

## 柔性事务的分类

柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。

- **两阶段型** 分布式事务二阶段提交，对应技术上的 XA、JTA/JTS，这是分布式环境下事务处理的典型模式。
- **补偿型** TCC 型事务（Try-Confirm-Cancel）可以归为补偿型。在 Try 成功的情况下，如果事务要回滚，Cancel 将作为一个补偿机制，回滚 Try 操作；TCC 各操作事务本地化，且尽早提交（没有两阶段约束）；当全局事务要求回滚时，通过另一个本地事务实现“补偿”行为。 TCC 是将资源层的二阶段提交协议转换到业务层，成为业务模型中的一部分。
- **异步确保型** 将一些有同步冲突的事务操作变为异步操作，避免对数据库事务的争用，如消息事务机制。
- **最大努力通知型** 通过通知服务器（消息通知）进行，允许失败，有补充机制。

# 分布式事务几种方案

#### 1. 2PC模式

数据库支持的2PC【2 phase commit二阶提交】，又叫做XA Transactions。

MySOL 从5.5版本开始支持，SQL Server 2005开始支持，Oracle 7开始支持。

其中，XA是一个两阶段提交协议，该协议分为以下两个阶段:|

- 第一阶段，事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交

- 第二阶段：事务协调器要求每个数据库提交数据。
  其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。

<center><img src="https://ss.im5i.com/2021/08/25/f6j3z.png" alt="f6j3z.png" border="0" /></center>

- XA协议比较简单，而且一旦商业数据库实现 XA 协议，使用分布式事务的成本也比较低

- **XA性能不理想**，特别是在交易下单链路，往往并发量很高，xA无法满足高并发场景

- XA目前在商业数据库支持的比较理想，**在mysql 数据库中支持的不太理想**，mysql的XA实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致

- 许多 nosql 也没有支持XA，这让XA的应用场景变得非常狭隘

- 也有3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理)

#### 2. 柔性事务-TCC事务补偿型方案

刚性事务：遵循ACID原则，强一致性

柔性事务：遵循BASE理论，最终一致性

与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致

<center><img src="https://ss.im5i.com/2021/08/25/f69aU.png" alt="f69aU.png" border="0" /></center>

一阶段 prepare行为：调用自定义的 prepare 逻辑。

二阶段 commit 行为：调用自定义的 commit 逻辑。

三阶段 rollback 行为：调用自定义的 rollback 逻辑。

所谓TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中。

#### 3. 柔性事务-最大努力通知型方案

按规律进行通知，**不保证数据一定能通知成功，但会提供可查询操作接口进行核对**。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送 http请求，设置最大通知次数。达到通知次数后即不再通知。

案例：银行通知、商户通知等(各大交易业务平台间的商户通知：多次通知、查询校对、对账文件)，支付宝的支付成功异步回调

#### 4. 柔性事务-可靠消息+最终一致性方案（异步确保型）

实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送

# SEATA

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案

# Reference

- [分布式事务中的TCC模型](https://help.aliyun.com/document_detail/132897.html)
- [SEATA](https://seata.io/zh-cn/docs/overview/what-is-seata.html)




































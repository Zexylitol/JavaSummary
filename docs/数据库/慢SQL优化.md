# 0. 前言

高CPU消耗、高执行时间、高IO消耗以及高影响行数的SQL语句都有可能是慢SQL。

从数据库角度看：每个SQL执行都需要消耗一定I/O资源，SQL执行的快慢，决定资源被占用时间的长短。

从应用的角度看：SQL执行时间长意味着等待，影响用户体验。

# 1. 治理的优先级

1. master数据库->slave数据库
   - 目前数据库基本上都是读写分离架构，读在从库（slave）上执行，写在主库（master）上执行。
   - 由于从库的数据都是从主库上复制过去的，主库等待较多的，会加大与从库的复制时延。
2. 执行次数多的SQL优先治理
3. 如果有一类SQL高并发集中访问某一张表，应当优先治理。

# 2. 影响因素

如不考虑MySQL数据库的参数以及硬件I/O的影响， 则影响SQL执行效率的因素主要是I/O和CPU的消耗量
总结：

1. 数据量：数据量越大需要的I/O次数越多
2. 取数据的方式
   - 数据在缓存中还是在磁盘上
   - 是否可以通过索引快速寻址
3. 数据加工的方式
   - 排序、子查询等，需要先把数据取到临时表中，再对数据进行加工
   - 增加了I/O，且消耗大量CPU资源

# 3. 解决思路

1. 将数据存放在更快的地方。
   - 如果数据量不大，变化频率不高，但访问频率很高，此时应该考虑将数据放在应用端的缓存当中或者Redis这样的缓存当中，以提高存取速度。如果数据不做过滤、关联、排序等操作，仅按照key进行存取，且不考虑强一致性需求，也可考虑选用NoSQL数据库。
2. 适当合并I/O
   - 分别执行select c1 from t1与select c2 from t1，与执行select c1,c2 from t1相比，后者开销更小。
   - 合并时也需要考虑执行时间的增加。
3. 利用分布式架构
   - 在面对海量的数据时，通常的做法是将数据和I/O分散到多台主机上去执行

# 4. 常见的慢查询优化

## 4.1 索引失效的情况

- 使用`like`模糊匹配以'%'开头
- 不符合最左前缀原则
- 使用不等于(`!=`或者`<>`)的时候无法使用索引
- 索引列上做了计算、函数、（自动or手动）类型转换等操作

## 4.2 优化数据库结构

合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容

- 是否符合三大范式
- 将字段很多的表分解成多个表
  -  对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢
- 增加中间表
  - 对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率
- 单表数据量过大时，对数据库进行水平分区，即分库分表，将原本一张表维护的海量数据分配给 N 个子表进行存储和维护

## 4.3 分解关联查询

 将一个大的查询分解为多个小查询是很有必要的。

很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：

```mysql
SELECT * FROM tag 
        JOIN tag_post ON tag_id = tag.id
        JOIN post ON tag_post.post_id = post.id
        WHERE tag.tag = 'mysql';
```

分解为：

```mysql
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id in (123,456,567);
```

## 4.4 优化LIMIT分页

在系统中需要分页的操作通常会使用`limit`加上偏移量的方法实现，同时加上合适的`order by`子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。

 一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是`limit 10000,20`这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。

优化此类查询的一个最简单的方法是**尽可能的使用索引覆盖扫描**，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。

例如，对于下面的查询：

```mysql
select id, title from collect limit 90000,10;
```

该语句存在的最大问题在于`limit M,N`中偏移量`M`太大（暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前`M`条记录，之后舍弃这`M`条记录并从第`M+1`条记录开始再依次找到`N`条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 试想，如下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。

**方法一：先查询出主键id值**

```mysql
select id, title 
from collect 
where id >= (select id from collect order by id limit 90000,1) 
limit 10;
```

原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据

**方法三："延迟关联"**

如果这个表非常大，那么查询可以改写成如下的方式：

```mysql
select news.id, news.description 
from news 
inner join (select id from news order by title limit 50000,5) as myNew 
using(id);
```

这里的“延迟关联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。

**方法四：建立复合索引acct_id和create_time**

 ```mysql
select * 
from acct_trans_log 
WHERE  acct_id = 3095  
order by create_time desc limit 0,10
 ```

>  注意sql查询慢的原因都是：引起filesort



# Reference

- [MySQL慢sql分析及优化](https://segmentfault.com/a/1190000006726948)
- [常见Mysql的慢查询优化方式](https://blog.csdn.net/qq_35571554/article/details/82800463)
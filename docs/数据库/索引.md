# 主键索引与唯一索引的区别

- 一个表的主键只能有一个，而唯一索引可以建多个。创建了一个主键的同时，也就为这个字段创建了一个唯一索引
- 主键可以作为其它表的外键
- 主键不可为null，唯一索引可以为null

# MySQL只能使用一个索引

如果在firstname、lastname、age这三个列上分别创建单列索引，效果是否和创建一个firstname、lastname、 age的多列索引一样呢？答案是否定的，两者完全不同。当我们执行查询的时候，MySQL只能使用一个索引。如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引，它的限制能力也肯定远远低于firstname、lastname、age这三个列上的多列索引。

# MySQL多条件查询索引为什么只用到一个？

> 如果经常需要同时对两个字段进行AND查询,那么使用两个单独索引不如建立一个复合索引，因为两个单独索引通常数据库只能使用其中一个，而使用复合索引因为索引本身就对应到两个字段上的，效率会有很大提高。

**与其说是“数据库查询只能用到一个索引”，倒不是说是 和 只使用一个索引的速度比起来，去分析两个索引二叉树更加耗费时间，所以绝大多数情况下数据库都是是用一个索引。**
如这条语句：

```mysql
select count(1) from table1 where column1 = 1 and column2 = 'foo' and column3 = 'bar'
```

我们来想象一下当数据库有N个索引并且查询中分别都要用上他们的情况：
查询优化器（用大白话说就是生成执行计划的那个东西）需要进行N次主二叉树查找[这里主二叉树的意思是最外层的索引节点]，此处的查找流程大概如下：

- 查出第一条column1主二叉树等于1的值，
- 然后去第二条column2主二叉树查出foo的值并且当前行的coumn1必须等于1，
- 最后去column主二叉树查找bar的值并且column1必须等于1和column2必须等于foo。

如果这样的流程被查询优化器执行一遍，就算不死也半条命了，查询优化器可等不及把以上计划都执行一遍，贪婪算法（最近邻居算法）可不允许这种情况的发生，**所以当遇到以下语句的时候，数据库只要用到第一个筛选列的索引（column1），就会直接去进行表扫描了**。

```mysql
select count(1) from table1 where column1 = 1 and column2 = 'foo' and column3 = 'bar'
```

所以与其说是数据库只支持一条查询语句只使用一个索引，倒不如说**N条独立索引同时在一条语句使用的消耗比只使用一个索引还要慢**。
所以如上条的情况，最佳推荐是使用index(column1,column2,column3） 这种联合索引，此联合索引可以把b+tree结构的优势发挥得淋漓尽致：
一条主二叉树（column=1），查询到column=1节点后基于当前节点进行二级二叉树column2=foo的查询，在二级二叉树查询到column2=foo后，去三级二叉树column3=bar查找

# 最左前缀

多列索引还有另外一个优点，它通过称为最左前缀（Leftmost Prefixing）的概念体现出来。继续考虑前面的例子，现在我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。当搜索条件是以下各种列的组合时，MySQL将使用fname_lname_age索引：

  \* firstname，lastname，age
  \* firstname，lastname
  \* firstname 

# 添加索引

## ALTER TABLE

- PRIMARY KEY 主键索引

```mysql
alter table `table_name` add primary key (`column`) ;
```

- UNIQUE唯一索引

```mysql
alter table `table_name` add unique (column_list) ;
```

- INDEX普通索引/复合索引

```mysql
alter table `table_name` add index index_name (column_list) ;
```

- FULLTEXT全文索引

```mysql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以同时创建多个索引

## CREATE INDEX

- 普通索引

```mysql
create index index_name on table_name (column_list) ;
```

- UNIQUE索引

```mysql
create unique index index_name on table_name (column_list) ;
```

说明：不能用CREATE INDEX语句创建PRIMARY KEY索引

## ALTER TABLE与CREATE INDEX的区别

- With CREATE INDEX, we must provide a name for the index. With ALTER TABLE, MySQL creates an index name automatically if you don’t provide one.

- Unlike ALTER TABLE, the CREATE INDEX statement can create only a single index per statement. 

  ```mysql
  ALTER TABLE HeadOfState ADD PRIMARY KEY (ID), ADD INDEX (LastName,FirstName);
  ```

- In addition, only ALTER TABLE supports the use of PRIMARY KEY.

# 删除索引

```mysql
drop index `index_name` on `table_name` ;
alter table `table_name` drop index `index_name` ;
alter table `table_name` drop primary key ;
```

说明：

- 在前两条语句中，都删除了table_name中的索引index_name。
- 最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。
- 如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。

# key和index区别

mysql的key和index多少有点令人迷惑，这实际上考察对数据库体系结构的了解

- key 是数据库的物理结构，<font color="red">它包含两层意义，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）</font>。包括primary key, unique key, foreign key 等。
  - primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个index
  - unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个index
  - foreign key也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index

- 可见，mysql的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别。（至少在[Oracle](http://lib.csdn.net/base/oracle)上建立外键，不会自动建立index），因此创建key也有如下几种方式：
  - 在字段级以key方式建立， 如 `create table t (id int not null primary key);`
  - 在表级以constraint方式建立，如`create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));`
  - 在表级以key方式建立，如`create table t(id int, primary key (id));`
- 其它key创建类似，但不管哪种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key

- index是数据库的物理结构，<font color="red">它只是辅助查询的</font>，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。如: `create table t(id int, index inx_tx_id  (id));`
-  我们说索引分类，分为主键索引、唯一索引、普通索引(这才是纯粹的index)等，也是基于是不是把index看作了key。
   比如 `create table t(id int, unique index inx_tx_id  (id));`  index当作了key使用
- 最重要的也就是，不管如何描述，理解index是纯粹的index，还是被当作key，**当作key时则会有两种意义或起两种作用**

# 索引规则

1、表的主键、外键必须有索引；
2、数据量超过300的表应该有索引；
3、经常与其他表进行连接的表，在连接字段上应该建立索引；
4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5、索引应该建在选择性高的字段上；
6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：

​	A、正确选择复合索引中的主列字段，一般是选择性较好的字段；

​	B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；

​	C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；

​	D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；

​	E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；

8、频繁进行数据操作的表，不要建立太多的索引；

9、删除无用的索引，避免对执行计划造成负面影响；

> 以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。

# 关于MySQL种的in函数到底走不走索引

结论：

- 当in()种的数据很大时，不走索引
- 当查询的列是char类型没有加引号，mysql优化器会自动给填充引号，同时也会导致索引失效
- 当in()中存在子查询、格式化函数等同样也会使索引失效！

# Reference

- [数据库中查询记录时是否每次只能使用一个索引？](https://www.cnblogs.com/technologykai/p/12576113.html)
- [mysql 添加索引，ALTER TABLE和CREATE INDEX的区别](https://blog.csdn.net/weixin_34128237/article/details/86346667)
- [[Mysql索引详解及优化(key和index区别)](https://www.cnblogs.com/jianmingyuan/p/6740090.html)](https://www.cnblogs.com/jianmingyuan/p/6740090.html)
- [多个条件的查询建立索引](https://blog.csdn.net/a812285851/article/details/54612918)
- [关于MySQL种的in函数到底走不走索引](https://www.pianshen.com/article/72732011789/)


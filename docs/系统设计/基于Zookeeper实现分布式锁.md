# 实现原理

（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建**临时顺序节点**；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

# 锁的释放

使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁

# 非阻塞锁

使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上**绑定监听器**，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点**是不是当前所有节点中序号最小的**，如果是，那么自己就获取到锁，便可以执行业务逻辑了。

# 锁重入

使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把**当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了**。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

# 单点问题

使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。




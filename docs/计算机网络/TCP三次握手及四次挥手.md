
# 1. TCP三次握手

## 1.1 TCP三次握手过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212310743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


最开始双方都处于`CLOSED`状态。然后服务端开始监听某个端口，进入了`LISTEN`状态

第一次握手：客户端主动发起连接，发送 `SYN` , 自己变成了`SYN-SENT`状态

第二次握手：服务端接收到，返回`SYN`和`ACK`(对应客户端发来的SYN)，自己变成了`SYN-REVD`

第三次握手：客户端再发送`ACK`给服务端，自己变成了`ESTABLISHED`状态；服务端收到`ACK`之后，也变成了`ESTABLISHED`状态

> 凡是需要对端确认的，一定消耗TCP报文的序列号
>
> `SYN` 需要对端的确认， 而 `ACK` 并不需要，因此 `SYN` 消耗一个序列号而 `ACK` 不需要

## 1.2 为什么TCP建立连接需要三次握手

- <font color="red">TCP作为一种可靠传输控制协议，其**核心思想**：既要保证**数据可靠传输**，又要**提高传输的效率**，而用**三次恰恰可以满足以上两方面的需求**</font>
- TCP连接三次握手的目的：
  - 确认双方的发送和接收能力正常
  - 确认通信双方数据原点的序列号（Initial Sequence Number，32位长，由操作系统动态随机选取），序列号就是给数据字节流进行编号
    - 通信双方分别以**该序列号为原点，对自己将要发送的每个字节的数据进行编号**，以便对方可以确认对方发送的每一个字节

### 1.2.1 握手为什么不是两次？

- **根本原因: 无法确认客户端的接收能力**
  - 第一次握手：客户端什么也确认不了，服务端可以确认客户端的发送能力和自己的接收能力
  - 第二次握手：客户端可以确认自己的发送和接收能力以及服务端的发送和接收能力
  - 第三次握手：服务端可以确认自己的发送能力和客户端的接收能力

- 假设握手两次就可以建立连接，此时已失效的连接请求报文段如果突然又传送到了服务端，就会产生错误
  - "已失效的连接请求报文段"产生在这样一种情况下：
    - 客户端发送了`SYN`报文想握手，但是这个包滞留在了网络中的某个节点迟迟没有到达，客户端以后是丢了包，于是重传`SYN`，服务端收到后然后返回`SYN+ACK`，两次握手建立好了连接
    - 看似没有问题，但是连接关闭后，如果之前滞留在网络中的`SYN`报文段到达了服务端，这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了，服务端却以为新的连接已经建立，并一直等待客户端发送数据，这样就带来了连接资源的浪费
    - 采用"三次握手"的办法就可以防止上述现象发生

### 1.2.2 握手为什么不是四次？

- **三次握手就可以确认双方发送和接收的能力了**，四次握手当然也可以，100次都可以，但是三次就足够了，第二次握手中`SYN`和`ACK`可以合并，**只需要三次握手，可以提高连接的速度与效率**

## 1.3 TCP第三次握手可以传输数据吗？

**第三次握手的时候，可以携带。前两次握手不能携带数据。**

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

**第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据**。

## 1.4 握手过程中丢包问题

- **第一个包，即A发给B的`SYN`中途被丢，没有到达B**
  - A会周期性超时重传，直到收到B的确认

- **第二个包，即B发给A的`SYN +ACK` 中途被丢，没有到达A**
  - B会周期性超时重传，直到收到A的确认（如果定时器到了，A也会重传，这个是双方独立控制的）

- **第三个包，即A发给B的`ACK`中途被丢，没有到达B**
  - A发完`ACK`，单方面认为TCP为 `Established`状态，而B显然认为TCP为`Active`状态
    - a. 假定此时双方都没有数据发送，B会周期性超时重传`SYN +ACK` ，直到收到A的确认，收到之后B的TCP连接也为 `Established`状态，双向可以发包
    - b. 假定此时A有数据发送，B收到A的 `Data + ACK`（除了第一个SYN报文，TCP报文都需要有ACK标志位），自然会切换为`established` 状态，并接受A的Data。
    - c. 假定B有数据发送，数据发送不了，会一直周期性超时重传`SYN + ACK`，直到收到A的确认才可以发送数据

## 1.5 双方同时发送SYN报文会怎么样？

双方同时发送`SYN`报文是一个可能会发生的情况，状态变迁如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212504847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


在发送方给接收方发`SYN`报文的同时，接收方也给发送方发`SYN`报文，两个人刚上了!

- 发完`SYN`，两者的状态都变为`SYN-SENT`

- 在各自收到对方的`SYN`后，两者状态都变为`SYN-REVD`

- 接着会回复对应的`ACK + SYN`，这个报文在对方接收之后，两者状态一起变为`ESTABLISHED`

## 1.6 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会**重新复位这个计时器**，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔75秒发送一次。**若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接**

## 1.7 半连接队列和 SYN Flood 攻击

三次握手前，服务端的状态从`CLOSED`变为`LISTEN`, 同时在内部创建了两个队列：**半连接队列**和**全连接队列**，即**SYN队列**和**ACCEPT队列**

### 1.7.1 半连接队列

当客户端发送`SYN`到服务端，服务端收到以后回复`ACK+SYN`，状态由`LISTEN`变为`SYN_RCVD`，此时这个连接就被推入了**SYN队列**，也就是**半连接队列**

### 1.7.2 全连接队列

当客户端返回`ACK`, 服务端接收后，三次握手完成。**这个时候连接等待被具体的应用取走**，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列(Accept Queue)**

### 1.7.3 SYN Flood 攻击原理

SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内**伪造大量不存在的 IP 地址，并向服务端疯狂发送`SYN`。对于服务端而言，会产生两个危险的后果**:

1. 处理大量的`SYN`包并返回对应`ACK`, 势必有大量连接处于`SYN_RCVD`状态，从而占满整个**半连接队列**，**无法处理正常的请求**
2. 由于是不存在的 IP，服务端长时间收不到客户端的`ACK`，**会导致服务端不断重发数据，直到耗尽服务端的资源**

### 1.7.4 如何应对 SYN Flood 攻击？

1. 增加 SYN 连接，也就是**增加半连接队列的容量**
2. **减少 SYN + ACK 重试次数，避免大量的超时重发**
3. 利用 SYN Cookie 技术，在服务端接收到`SYN`后**不立即分配连接资源**，而是根据这个`SYN`计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复`ACK`的时候带上这个`Cookie`值，**服务端验证 Cookie 合法之后才分配连接资源**

# 2. TCP四次挥手

## 2.1 TCP四次挥手过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042421264533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


刚开始双方处于`ESTABLISHED`状态。

客户端要断开了，向服务器发送 `FIN` 报文，发送后客户端变成了`FIN-WAIT-1`状态。注意, **这时候客户端同时也变成了`half-close(半关闭)`状态，即无法向服务端发送报文，**只能接收

服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态

客户端接收到了服务端的确认，变成了`FIN-WAIT2`状态

随后，服务端向客户端发送`FIN`，自己进入`LAST-ACK`状态

客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 `ACK` 给服务端

这个时候，客户端需要等待足够长的时间，具体来说，**是 2 个 `MSL`(`Maximum Segment Lifetime，报文最大生存时间`),** 在**这段时间内如果客户端没有收到服务端的重发请求，那么表示 `ACK` 成功到达，挥手结束，否则客户端重发 `ACK`**。

## 2.2 为什么关闭连接是四次挥手？

TCP属于全双工通信，关闭连接时，**服务器收到对方的`FIN`报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必将全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送`FIN`报文给对方来表示同意现在关闭连接，因此，己方`ACK`和`FIN`一般都会分开发送，从而导致了四次挥手**

### 2.2.1 如果三次挥手会有什么问题？

三次挥手等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，这个时候**长时间的等待**可能会导致客户端误以为`FIN`没有到达服务端，从而让客户端不断的重发`FIN`

## 2.3 TCP四次挥手为什么有Time-Wait过程？

TIME-WAIT通常**是 2 个 `MSL`(`Maximum Segment Lifetime，报文最大生存时间`)**

### 2.3.1 如果不等待会怎么样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么**就接收到了无用数据包，造成数据包混乱**。所以，最保险的做法是等服务器发来的数据包都消失在网络中再启动新的应用

### 2.3.2 等待的意义

第一，**保证客户端发送的最后一个`ACK`报文能够到达服务器(也要保证ACK报文丢失的情况下，重传的FIN报文可以达到客户端)**，因为这个`ACK`报文可能丢失，站在服务器的角度看来，我已经发送了`FIN+ACK`报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，**而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器**。

第二，防止类似与“三次握手”中提到了的**“已经失效的连接请求报文段”出现在本连接中**。客户端发送完最后一个确认报文后，**在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文**

### 2.3.3 为什么是2MSL?

- **1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能到达对端**
- **1 个 MSL 确保对端没有收到 ACK 时重传的 FIN 报文可以到达主动关闭方**

## 2.4 双方同时关闭会怎样？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212751844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)


双方同时断开并不要求双方在同一时间点发送断开的请求，只要是对方的断开请求还没收到，这时发出断开请求，都算是同时断开。 同时断开的场景双方的状态变化是一致的(不要求时间一致)

双方发送`FIN`报文后，都进入`FIN_WAIT_1`状态

接收到对方的`FIN`报文后，进入`CLOSING`状态，并向对方发送`ACK`

接收到对方的`ACK`报文后，进入`TIME-WAIT`状态，等待2MSL后，关闭连接

## 2.5 如何解决TIME_WAIT过多

### 2.5.1 大量TIME_WAIT造成的影响

在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

为什么我们要关注这个高并发短连接呢？有两个方面需要注意：

1. **高并发可以让服务器在短时间范围内同时占用大量端口**，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。

2. 在这个场景中，**短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接**。

- 这里有个相对长短的概念，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，**而这几分钟，其他HTTP请求来临的时候是无法占用此端口的**

- 单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIME_WAIT状态。同时，在实际业务场景中，一般**长连接对应的业务的并发量并不会很高**。)

这两个方面，持续的到达一定量的高并发短连接，**会使服务器因端口资源不足而拒绝为一部分客户服务**。同时，这些端口都是服务器临时分配，无法用SO_REUSEADDR选项解决这个问题。

### 2.5.2 如何解决TIME_WAIT过多

修改内核参数：降低MSL周期，也就是tcp_fin_timeout值，同时增加time_wait的队列（tcp_max_tw_buckets），打开系统的TIMEWAIT重用和快速回收。

```shell
net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout #修改系默认的 TIMEOUT 时间
```

然后执行 /sbin/sysctl -p 让参数生效.

```shell
/etc/sysctl.conf # 是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。
```

如果以上配置调优后性能还不理想，可继续修改一下配置：

```shell
vi /etc/sysctl.conf
net.ipv4.tcp_keepalive_time = 1200 
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.ip_local_port_range = 1024 65000 
#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
net.ipv4.tcp_max_syn_backlog = 8192 
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_tw_buckets = 5000 
#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
#默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
```



# 3. TCP状态转换图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212820651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5bGl0b2x6,size_16,color_FFFFFF,t_70#pic_center)

# 4. TCP三次握手时，IP层和MAC层在做什么呢？

**当然是TCP发送的每一个消息，都会带着IP层和MAC层了**。因为，TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍。你只看到TCP三次握手了，其实，IP层和MAC层为此也忙活好久了。

> <span style="color:red">只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层</span>

所以，对TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出去的。

经常有人会问这样一个问题，我都知道那台机器的IP地址了，直接发给他消息呗，要MAC地址干啥？这里的关键就是，**没有MAC地址消息是发不出去的。**

所以如果一个HTTP协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。

**所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已**。一个HTTP协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面HTTP、TCP、IP、MAC都有。什么叫二层设备呀，就是只把 MAC头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢?就是把 MAC头摘下来之后，再把IP头摘下来，看看到底是丢弃、转发，还是自己留着。

# 5. 异常处理

> 总的原则：ACK不会重传，SYN和FIN报文段有最大重传次数。无论是SYN还是FIN，达到最大重传次数后对端若仍无响应则直接进入CLOSED状态

## 5.1 尝试连接IP不存在或端口存在的目的主机

## 5.1.1 当试图连接一个IP不存在的主机时

- 如果尝试连接的IP在局域网内，则会发送N次ARP请求，向局域网内请求获取目的主机的MAC地址，且本地主机不能发出TCP握手消息

- 如果尝试连接的IP在局域网外，则会将TCP握手消息通过网关路由发出到局域网外，但因为最终找不到目的地，会触发TCP的超时重传，直至达到最大重传次数后关闭TCP连接

## 5.1.2 当试图连接一个IP存在但端口不存在的主机时

- 不论尝试连接的主机是在局域网内还是局域网外，当目的主机收到源主机的TCP握手消息后，判断这个端口上并没有应用进程，内核协议栈会立即回复RST复位报文段，发送端在收到RST后关闭TCP连接

- 如果目的主机设置了防火墙策略，限制他人将消息发送到不对外暴露的端口，那么这种情况目的主机会将收到的TCP握手消息直接丢弃，源主机在超时后进行重传，直至达到最大重传次数后关闭TCP连接

# Reference

- [TCP协议面试10连问](https://mp.weixin.qq.com/s/_NDcAZLCL0vvjzu4Sv41Hg)
- [TCP为什么是三次握手-车小胖](https://www.zhihu.com/question/24853633)
- [TCP三次握手详解](https://blog.csdn.net/jun2016425/article/details/81506353)
- [TCP同时断开](http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm)
- [趣谈网络协议](https://time.geekbang.org/column/intro/85)
- [TCP三次握手及四次挥手过程中的异常处理](https://blog.csdn.net/ArtAndLife/article/details/120004631)
- [解决TIME_WAIT过多造成的问题](https://www.cnblogs.com/dadonggg/p/8778318.html)
- [解决CLOSE_WAIT、TIME_WAIT等连接状态过多的问题](https://blog.csdn.net/a13568hki/article/details/103858890/)
# TCP头部

<center><img src="https://img-blog.csdn.net/20180501221501343?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE3NjExMjg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"/></center>

### 源端口、目标端口

如何标识唯一标识一个连接？答案是 TCP 连接的`四元组`——源 IP、源端口、目标 IP 和目标端口。

那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。

### 序列号

即`Sequence number`, 指的是**本报文段第一个字节的序列号**。

从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 $0 - (2^{32} - 1)$​。如果到达最大值了后就循环到0。

**序列号在 TCP 通信的过程中有两个作用：**

1. **在 SYN 报文中交换彼此的初始序列号**
2. **保证数据包按正确的顺序组装**

### ISN

即`Initial Sequence Number（初始序列号）`,在三次握手的过程当中，双方会用过`SYN`报文来交换彼此的 `ISN`。

ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？

**如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的**

而动态增长的 ISN 大大提高了猜测 ISN 的难度。

### 确认号

即`ACK(Acknowledgment number)`。**用来告知对方下一个期望接收的序列号**，**小于ACK**的所有字节已经全部收到。

### 标记位

常见的标记位有`SYN`,`ACK`,`FIN`,`RST`,`PSH`。

SYN 和 ACK 已经在上文说过，后三个解释如下: `FIN`：即 Finish，表示发送方准备断开连接。

`RST`：即 Reset，用来强制断开连接。

`PSH`：即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。

### 窗口大小

占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。

### 校验和

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。

### 可选项

可选项的格式如下:

<center><img src="https://i.loli.net/2021/04/09/JE1pvHXimj8FDRu.png"/></center>

常用的可选项有以下几个：

- TimeStamp: TCP 时间戳，后面详细介绍
- MSS: 指的是 TCP 允许的从对方接收的最大报文段
- SACK: 选择确认选项
- Window Scale：窗口缩放选项

# IPv4头部

<center><img src="https://i.loli.net/2021/04/08/wMiqerzbpvVhyRL.png"/></center>

# TCP如何确保可靠性传输

## 通过序列号与确认应答提高可靠性

- TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，叫做确认应答（ACK）。
- 在一定时间内没有收到确认应答，发送端就可以认为数据已经丢失，并进行**重发**
  - 未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到，只是**返回的确认应答在途中丢失**。都会导致重发
    - 接收方**会第二次发送已接收此数据的确认应答，但会丢弃重复的数据包**

- **序列号是按顺序给发送数据的每一个字节（8位字节）都标上编号**
  - **接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去**
    - TCP的数据长度并未写入TCP首部
    - <span style="color:red">TCP包的长度 = IP首部中的数据包长度 - IP首部长度 - TCP首部长度</span>

- 通过序列号和确认应答号，TCP可以实现可靠传输

## 重发超时如何确定

<center><img src="https://i.loli.net/2021/04/08/IOCmN78glua1wQc.png"/></center>

- 如果超过了超时时间仍未收到确认应答，发送端将进行数据重发
- 根据**不同的网络环境**以及不同时段的**网络拥堵程度**，超时时间会发生变化
- TCP要求不论处在何种网络环境下都要提供高性能通信。<font color="red">为此，它在每次发包时都会计算**往返时间（Round Trip Time, RTT）及其偏差（RTT的方差，也叫抖动）**。将这个往返时间和偏差相加，重发超时的时间就是比这个总和要稍大一点的值</font>。
  - 重发超时的计算既要考虑往返时间又要考虑偏差是有其原因的：根据网络环境的不同往返时间可能会**产生大幅度的摇摆**，之所以发生这种情况是因为数据包的分段是经过不同线路到达的，**TCP/IP的目的是即使在这种环境下也要进行控制，尽量不要浪费网络流量**

- **重发超时都是0.5秒的整数倍（偏差的最小值也是0.5毫秒，因此最小的重发时间至少是1秒）**，由于最初的数据包还不知道往返时间，所以其重发超时一般设置为6秒左右
- 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，**等待确认应答的时间将以2倍、4倍的指数函数延长**
- 数据也不会被无限、反复地重发。**达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接**，并且通知应用通信异常强行终止

## 连接管理

- 一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成（三次握手+四次挥手）

<center><img src="https://i.loli.net/2021/04/08/2kCKwPb4dYmNtqG.png"/></center>

## TCP以段为单位发送数据

- 在建立TCP连接的同时，也可以确定发送数据包的单位：**MSS（Maximum Segment Size, 报文最大长度）**
- 最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度
- TCP在传送大量数据时，是**以MSS的大小将数据进行分割发送**，进行重发时也是以MSS为单位
- MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，**会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小**（为附加MSS选项，TCP首部将不再是20字节，而是4字节的整数倍（20+4）），然后会在两者之间**选择一个较小的值投入使用**（**如果某一方的MSS选项被省略，可以选为IP包的长度不超过576字节的值（IP首部20字节，TCP首部20字节，MSS 536字节**））

<center><img src="https://i.loli.net/2021/04/08/3fPRyJn7jFAorvx.png"/></center>

## 利用窗口控制提高速度

<center><img src="https://i.loli.net/2021/04/08/dKVE4cxn87jztew.png"/></center>

为了解决上述问题，TCP引入了**窗口**这个概念。确认应答不再是以每个分段，而是**以更大的单位进行确认时**，转发时间将会被大幅度的缩短，**用滑动窗口方式并行处理**，如下图所示：

<center><img src="https://i.loli.net/2021/04/08/F749ymQwEuYfvcT.png"/></center>

<span style="color:red">窗口大小就是指无需等待确认应答而可以继续发送数据的最大值</span>，上图中窗口大小为4个段。这个机制实现使用了**大量的缓冲区**，通过对多个段同时进行确认应答

<center><img src="https://i.loli.net/2021/04/08/qVjPlW7GOAnfH15.png"/></center>

<center><img src="https://i.loli.net/2021/04/08/NbHxCwygVjmUET6.png"/></center>

## 窗口控制与重发控制

- 在使用窗口控制中，如果出现段丢失该怎么办？

### 确认应答未能返回的情况

- 在这种情况下，数据已经到达了对端，是不需要再进行重发的

- 在**没有使用窗口控制**的情况下，没有收到确认应答的数据都会被重发
- 而**使用了窗口控制**，某些确认应答即便丢失也无需重发（**可以通过下一个确认应答进行确认**）

<center><img src="https://i.loli.net/2021/04/08/GbBJI1cMoDZpOWu.png"/></center>

### 某个报文段丢失的情况

- 如下图所示，接收主机如果**收到一个自己应该接收的序号以外的数据（接收端没有收到自己所期望序号的数据时）**，**会针对当前为止收到数据返回确认应答**（即使接收端收到的包序号不连续，也不会将数据丢弃而是暂时保存至缓冲区）

<center><img src="https://i.loli.net/2021/04/08/vyuI1jpGBDCmJSM.png"/></center>

<center><img src="https://i.loli.net/2021/04/08/n8HsiNMP2I3YpwG.png"/></center>

<span style="color:red">**高速重发控制（Fast Retransmission）**：发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发</span>

- 之所以连续收到3次而不是两次的理由是因为：**即使数据段的序号被替换两次也不会触发重发机制**

## 流控制

- **发送端根据自己的实际情况发送数据**，但是，接收端处理数据包会花费一些时间，**甚至在高负荷的情况下无法接收任何数据**，如此一来，如果接收端将**本来应该接收的数据丢弃的话**，就又会触发重发机制，**从而导致网络流量的无端浪费**
- 为了防止上述现象的发生，TCP提供了一种机制<font color="red">**让发送端根据接收端的实际接收能力控制发送的数据量**</font>，这就是所谓的**流控制**
  - 接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，**该大小限度就称作窗口大小**
  - **TCP首部中，专门有一个字段用来通知窗口大小**。接收端主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。**这个字段值越大，说明网络的吞吐量越高**
- 下图为根据窗口大小控制流量过程的示例：

<center><img src="https://i.loli.net/2021/04/08/jhb7OUYQKpvB5uJ.png"/></center>

**如果窗口的更新通知在传送途中丢失**，可能导致无法继续通信，为避免此类问题的发生，发送端主机会时不时的发送一个叫做<font color="red">**窗口探测的数据段**</font>，**此数据段仅含一个字节以获取最新的窗口大小信息**

## 拥塞控制

- 有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包，然而，**如果在通信刚开始时就发送大量数据，也可能引发其他问题**
  - **在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪**
- TCP为了防止上述问题的出现，在**通信一开始**时就会通过一个叫做<span style="color:red">**慢启动**</span>的算法得出的数值，<font color="red">**对发送数据量进行控制**</font>

<center><img src="https://i.loli.net/2021/04/08/jMwGN9cHBCbnL3Y.png"/></center>

首先，**为了在发送端调节所要发送数据的量**，定义了一个叫做“拥塞窗口”的概念，**于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS）发送数据**，**之后每收到一次确认应答（ACK），拥塞窗口的值就加1个段。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小那个值，发送比其还要小的数据量**

- 连接建立以后即刻从1MSS开始进行慢启动的话，通过卫星通信等手段**提高通信吞吐量所耗的时间会比较长**，为此，有时也会将慢启动的初始值设置为大于1MSS的值，具体来说：
  - MSS的值 小于 1095字节时，最大为4MSS
  - MSS的值 小于 2190字节时，最大为4390字节（2MSS）
  - MSS的值 超过 2190字节时，最大值大于2MSS
  - **以太网的标准MSS值为1460字节，因此慢启动的初始值从4380字节（3MSS）开始就可以**

<center><img src="https://i.loli.net/2021/04/08/9tmpVsSLiF3jqkx.png"/></center>

### 重发采用超时机制

- 如果重发采用超时机制，那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制，**就可以有效地减少通信开始时连续发包导致的网络拥堵，还可以避免网络拥塞情况的发生**
  - 连续发包的情况也叫“爆发”（Burst），**慢启动正是减少爆发等网络拥堵情况的一种机制**

- 不过，**随着包的每次往返**，拥塞窗口也会以1、2、4等指数函数的增长，**拥堵状况激增，甚至导致网络拥堵的发生**。
  - 为了防止这些，引入了<span style="color:red">**慢启动阈值**</span>的概念
  - **只要拥塞窗口的值超出这个阈值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口**：

<center><img src="https://i.loli.net/2021/04/08/JNmu1MwtTzLsGPW.png"/></center>

- 拥塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，**其涨幅也会逐渐减少**，甚至小过比一一个数据段还要小的字节数。因此，**拥塞窗口的大小会呈直线上升的趋势**。
- <font color="red">**TCP通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口一半的大小**</font>

### 高速重发控制

- 由重复确认应答而触发的高速重发与超时重发机制的处理多少有些不同。因为前者要求**至少3次的确认应答数据段到达对方主机后**才会触发，相比后者网络的拥堵要轻一些。

- 由**重复确认应答进行高速重发控制**时**，慢启动阀值的大小被设置为当时窗口大小的一半**。**然后将窗口的大小设置为该慢启动阀值+3个数据段的大小**。
- 有了这样一种控制，TCP的拥塞窗口如图所示发生变化。**由于窗口的大小会直接影响数据被转发时的吞吐量**，所以一般情况下，**窗口越大，越会形成高吞吐量的通信**。

当TCP通信开始以后，**网络吞吐量会逐渐上升，但是随着网络拥堵的发生吞吐量也会急速下降。于是会再次进人吞吐量慢慢上升的过程**。因此所谓TCP的吞吐量的特点就好像是在逐步占领网络带宽的感觉。